[Книга](https://www.labirint.ru/books/662585/)

1. [[#Глава 1.2. Язык ассемблера]]
2. [[#Глава 1.3. Программирование]]
3. [[#Глава 1.4. Машинный язык]]
4. [[#Глава 1.5. Свет, камера, мотор! Компилируем, ассемблируем и загружаем]]
5. 
## Глава 1.2. Язык ассемблера

Раздел 1.2 "Язык ассемблера" из предоставленных источников описывает основы языка ассемблера ARM, включая его **команды** и **операнды**.

**Команды**
- Команды языка ассемблера определяют операцию, которую нужно выполнить.
- Для обозначения операций используются **мнемоники**, такие как ADD (сложение) и SUB (вычитание). Мнемоники проще запомнить, чем двоичные коды машинного языка.
- Архитектура ARM использует единообразный формат команд, например, с двумя операндами-источниками и одним операндом-приемником (результатом). Единообразие формата упрощает аппаратную реализацию.
- Более сложный код с языка высокого уровня транслируется в несколько команд ARM.
- Команды могут выполняться **условно** в зависимости от флагов состояния. Условное выполнение команд может быть короче и быстрее, чем использование команд перехода.
- Существуют команды **безусловного перехода** (например, B) и **условного перехода** (например, BEQ - переход по равенству).

**Операнды**
- Команда оперирует данными, которые называются **операндами**.
- Компьютеры работают с двоичными данными.
- Команда должна знать, откуда брать данные. Операнды могут находиться в **регистрах**, **памяти** или быть **константами**.

**Регистры**
- Архитектура ARM определяет 16 регистров.
- Регистры R0–R12 служат для хранения переменных.
- Регистры R0–R3 используются также особым образом при вызове процедур (для аргументов и возвращаемого значения), а также как временные переменные.
- Регистры R4–R11 используются для сохранения переменных.
- R12 является временным регистром.
- R13 называется SP (Stack Pointer - указатель стека).
- R14 называется LR (Link Register - регистр связи) и содержит адрес возврата для вызова функций.
- R15 называется PC (Program Counter - счетчик команд).
- В примерах кода на языке ассемблера ARM регистры используются для хранения переменных и промежуточных результатов, например, R0 = a, R1 = b, R2 = c. Для промежуточных значений могут использоваться временные регистры, такие как R4.
- Архитектура ARM (версия 4, которая рассматривается подробно) является 32-битовой, что означает, что регистры имеют размер 32 бита.

**Константы (непосредственные операнды)**
- Значение константы является частью самой команды, поэтому не требуется доступ к регистрам или памяти для ее получения.
- В ассемблерном коде константы обозначаются знаком **#** перед значением.
- Значение константы может быть записано в десятичном или шестнадцатеричном (с префиксом 0x) виде.
- Непосредственные операнды обычно представляют собой 8- или 12-битовые числа без знака.
- Примеры использования констант: `ADD R7, R7, #4`.
- Команда MOV может использоваться для инициализации регистров непосредственными операндами.

**Память**
- Операнды могут также находиться в памяти.
- Архитектура ARM использует побайтовую адресацию памяти с 32-битовыми адресами.
- Доступ к памяти (загрузка и сохранение данных) осуществляется с помощью специальных команд, таких как LDR (загрузка) и STR (сохранение). (Хотя эти команды подробно рассматриваются в разделе 1.3.6 и далее, концепция памяти как места хранения операндов вводится в разделе 1.2).

В целом, раздел 1.2 закладывает основу для понимания языка ассемблера ARM, вводя ключевые понятия команд, мнемоник, операндов, а также описывая основные типы мест хранения операндов: регистры и константы.

## Глава 1.3. Программирование

- **Трансляция высокоуровневого кода:** Простые операции могут транслироваться в одну команду ассемблера (например, `a = b + c;` в `ADD a, b, c;`), а более сложные конструкции или выражения могут требовать нескольких команд. Использование нескольких команд для сложных операций иллюстрирует **второй принцип хорошего проектирования компьютерной архитектуры: типичный сценарий должен быть быстрым**.
- **Комментарии:** В языке ассемблера ARM используются однострочные комментарии, начинающиеся с символа `;`. В языках высокого уровня, как правило, поддерживаются как однострочные (`//`), так и многострочные (`/* */`) комментарии.
- **Массивы:** Однородные данные могут быть сгруппированы в массивы, которые хранятся в непрерывных участках памяти с последовательными адресами. Доступ к элементам массива по индексу требует масштабирования индекса (умножения на размер элемента, например, на 4 для 32-битовых слов) перед прибавлением к базовому адресу массива. ARM поддерживает адресацию со смещением, а также с предындексацией и постиндексацией для работы с массивами.
- **Функции (Процедуры/Подпрограммы):** Языки высокого уровня поддерживают функции для повторного использования кода, улучшения модульности и удобочитаемости. Функции принимают входные данные (аргументы) и могут возвращать результат (возвращаемое значение).

**Особое внимание в главе уделяется использованию стека при вызовах функций:**
- **Проблема сохранения состояния:** При вызове одной функции из другой вызванная функция может изменить значения регистров, которые требуются вызывающей функции после возврата. Чтобы решить эту проблему, используется стек.
- **Принцип работы стека:** Стек является структурой данных, которая, как правило, **растет вниз** (к меньшим адресам) и работает по принципу **LIFO (Last-In, First-Out)**. Он используется для хранения временных данных, локальных переменных и сохранения состояния регистров.
- **Процесс вызова функции с использованием стека:**
    1. Вызванная функция **выделяет место в стеке**, уменьшая значение указателя стека (SP).
    2. Вызванная функция **сохраняет значения регистров** в выделенное пространство в стеке.
    3. Функция выполняет свои действия, при необходимости изменяя значения регистров.
    4. Перед возвратом функция **восстанавливает исходные значения регистров** из стека.
    5. Вызванная функция **освобождает место в стеке**, увеличивая значение указателя стека (SP) на то же значение, на которое он был уменьшен при входе.
- **Соглашение о регистрах:** Существует стандарт вызова процедур для архитектуры ARM, который определяет, какие регистры являются **оберегаемыми вызываемой функцией (callee-save)** и какие - **оберегаемыми вызывающей функцией (caller-save)**.
    - **Caller-save регистры (R0–R3 и R12):** Вызывающая функция **должна сохранить** эти регистры, если они понадобятся ей после вызова другой функции.
    - **Callee-save регистры (например, R4, R8, R9 в примерах):** Вызываемая функция **должна сохранить** эти регистры, если она планирует их использовать и изменить их значения, чтобы вызывающая функция после возврата обнаружила их в исходном состоянии.
- **Передача аргументов и локальные переменные:** Первые четыре аргумента функции обычно передаются в регистрах R0–R3. Дополнительные аргументы (более четырех) передаются в стеке, и место для них выделяет **вызывающая функция** непосредственно перед указателем стека. Локальные переменные, для которых не хватило регистров, также хранятся в стеке.
- **Адрес возврата:** Регистр R14 (LR, регистр связи) содержит адрес команды, на которую нужно вернуться после выполнения вызова функции (после команды `BL`). Этот адрес также может быть сохранен в стеке, если вызванная функция, в свою очередь, вызывает другую функцию.
- **Стек при обработке исключений:** В ARM предусмотрены отдельные стеки для различных режимов выполнения (например, режим пользователя и режим супервизора). При возникновении исключения процессор переключается на соответствующий стек и сохраняет состояние регистров, чтобы затем вернуться к прерванной программе. Режим быстрого прерывания (FIQ) имеет отдельный банк регистров R8-R12, которые не нужно сохранять в стеке при входе в обработчик, что ускоряет его выполнение.

## Глава 1.4. Машинный язык

- **Команды обработки данных:** Это наиболее распространенный формат команд. 32-битовая команда обработки данных ARM состоит из шести полей: `cond`, `op`, `funct`, `Rn`, `Rd` и `Src2`.
    - Поле `cond` (4 бита, 31:28) кодирует условие выполнения команды в зависимости от флагов состояния. Значение `1110` в этом поле означает безусловное выполнение.
    - Поле `op` (2 бита, 27:26) и поле `funct` (6 бит, 25:20) совместно кодируют выполняемую операцию (мнемонику). Для команд обработки данных поле `op` равно `00`.
    - Поле `Rn` (4 бита, 19:16) указывает первый регистр-источник.
    - Поле `Rd` (4 бита, 15:12) указывает регистр-приемник, куда записывается результат. Важно отметить, что в ассемблерном коде регистр-приемник указывается первым, а в машинной команде ARM он находится во втором регистровом поле (`Rd`).
    - Поле `Src2` (12 бит, 11:0) кодирует второй операнд-источник. Он может быть либо регистром (возможно, сдвинутым), либо непосредственным операндом (константой). Кодирование сдвига (LSL, LSR, ASR, ROR) осуществляется в полях внутри `Src2` при использовании регистра.
- **Команды доступа к памяти:** Команды загрузки (`LDR`) и сохранения (`STR`) слов (`LDR`/`STR`), байтов (`LDRB`/`STRB`), полуслов (`LDRH`/`STRH`) и байтов/полуслов со знаком (`LDRSB`/`LDRSH`) используются для взаимодействия с памятью.
    - Для команд `LDR`, `STR`, `LDRB`, `STRB` (слово/байт) поле `op` равно `01`.
    - Для команд `LDRH`, `STRH`, `LDRSB`, `LDRSH` (полуслово/байт со знаком) поле `op` равно `00`, и они имеют меньшую гибкость в кодировании второго операнда (`Src2`), где непосредственное смещение занимает только 8 бит, а регистровое не может быть сдвинуто.
    - В машинный код команд доступа к памяти также входят биты, управляющие типом индексации (`P`, `W`) и типом операции (`L`, `B`). Например, биты `P` и `W` определяют постиндексацию (`00`), смещение (`10`) или предындексацию (`11`). Биты `L` и `B` определяют `STR` (`00`), `STRB` (`01`), `LDR` (`10`) или `LDRB` (`11`).
- **Команды перехода:** Команды безусловного перехода (`B`) и перехода с сохранением адреса возврата (`BL`) имеют свое машинное представление.
    - Для команд перехода поле `op` равно `10`.
    - Команда `BL` включает 24-битовое поле `imm24`, кодирующее смещение целевого адреса относительно счетчика команд (`PC`), увеличенного на 8 байт (две команды).
- **Режимы адресации:** В машинный код команды доступа к памяти или операнда `Src2` включается информация о режимах адресации. Источники упоминают и показывают примеры кодирования для:
    - **Непосредственного операнда:** Значение константы является частью самой команды. В ассемблере обозначается `#`. Для команд обработки данных константы обычно 8- или 12-битовые. Для доступа к памяти непосредственное смещение может быть до 4095 байт для команд слова/байта. Большие константы и адреса загружаются через пул литералов с использованием `LDR` относительно `PC`.
    - **Регистрового операнда:** Операнды находятся в регистрах.
    - **Смещения:** Адрес вычисляется как сумма базового регистра и непосредственного смещения или смещения из другого регистра.
    - **Масштабированного регистрового смещения:** Индексный регистр масштабируется (сдвигается), а затем прибавляется к базовому адресу. Это полезно для доступа к элементам массива, где смещение равно `индекс * размер_элемента`.
    - **Предындексации и постиндексации:** Эти режимы кодируются битами `P` и `W` в команде доступа к памяти. Они определяют, происходит ли обновление базового регистра _до_ (`!`) или _после_ (`[]`) обращения к памяти.
    - **Адресации относительно счетчика команд (PC):** Используется для команд перехода (`B`, `BL`) и для загрузки констант или адресов из пула литералов.
- **Интерпретация кода на машинном языке:** Чтобы понять машинный код, нужно декодировать поля 32-битового слова команды. Процесс начинается с анализа полей `cond` и `op`.
    - `op = 00` указывает на команду обработки данных. Затем анализируются поля `funct` (включая I-бит) для определения конкретной операции и операндов (`Rn`, `Rd`, `Src2`).
    - `op = 01` указывает на команду доступа к памяти. Анализируются биты `funct` (`B`, `L`) и флаги индексации (`P`, `W`, `I`) для определения операции (`LDR`/`STR`...), режима адресации и операндов (`Rn`, `Rd`, смещение/регистр).
    - `op = 10` указывает на команду перехода. Анализируются соответствующие поля (например, `imm24` для `BL`) для определения цели перехода.

## Глава 1.5. Свет, камера, мотор! Компилируем, ассемблируем и загружаем

- **Компиляция**: Компилятор транслирует программу с языка высокого уровня на язык ассемблера.
- **Ассемблирование**: Ассемблер транслирует ассемблерный код в машинный код и сохраняет результат в объектный файл. Объектный файл можно дизассемблировать, чтобы увидеть ассемблерный код, соответствующий машинному.
- **Компоновка**: Компоновщик объединяет машинный код из объектных файлов с кодом из библиотек и других файлов. Он также вычисляет адреса переходов и переменных, формируя исполняемый файл программы. Компоновщик перемещает данные и команды в объектных файлах так, чтобы они не перекрывались, и использует информацию из таблиц символов для коррекции адресов перемещаемых глобальных переменных и меток. Исполняемый файл содержит обновленную таблицу символов с перемещенными адресами функций и глобальных переменных.
- **Загрузка**: Операционная система загружает программу, считывая сегмент кода из исполняемого файла (обычно с жесткого диска) в сегмент кода в оперативной памяти. Затем операционная система выполняет переход в начало программы, тем самым начиная ее выполнение.
* На практике большинство компиляторов выполняют первые три шага: компиляцию, ассемблирование и компоновку.

**Карта памяти** ARM определяет, где располагаются различные части программы. При запуске программы память обычно делится на несколько сегментов:
- **Сегмент кода** (.text): Содержит машинные команды программы. Этот сегмент считывается из исполняемого файла и загружается в память операционной системой. Машинная программа представляет собой последовательность 32-битовых чисел, представляющих команды, которые могут храниться в памяти.
- **Сегменты данных** (.data, .bss): Содержат данные программы. Например, глобальные переменные могут храниться в этих сегментах. Операнды, с которыми работает команда, могут находиться в памяти. Массивы, например, располагаются в ячейках памяти с последовательными адресами, занимая непрерывный участок памяти.
- **Стек**: Представляет собой область памяти, используемую для хранения локальных переменных функции. Стек расширяется, когда процессору нужно больше места, и сжимается, когда сохраненные там переменные больше не нужны. Дополнительные аргументы функций (сверх первых четырех) и локальные переменные, для которых не хватает регистров, хранятся в стеке. В стеке также хранятся и восстанавливаются регистры, например, регистр связи LR при вызове нелистовых функций. Каждому режиму выполнения может соответствовать свой собственный стек.

## Глава 1.6. Дополнительные сведения


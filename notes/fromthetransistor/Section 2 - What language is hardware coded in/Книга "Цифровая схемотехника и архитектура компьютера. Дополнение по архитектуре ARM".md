[Книга](https://www.labirint.ru/books/662585/)

1. [[#Глава 1.2. Язык ассемблера]]
2. [[#Глава 1.3. Программирование]]
3. [[#Глава 1.4. Машинный язык]]
4. [[#Глава 1.5. Свет, камера, мотор! Компилируем, ассемблируем и загружаем]]
5. [[#Глава 1.6. Дополнительные сведения]]
6. [[#Глава 1.7. Эволюция архитектуры ARM]]
7. [[#Глава 1.8. Живой пример архитектура х86]]
8. [[#Глава 1.9. Резюме]]
9. [[#Глава 2.1. Введение]]
10. [[#Глава 2.2. Анализ производительности]]
11. [[#Глава 2.3. Однотактный процессор]]
12. [[#Глава 2.4. Многотактный процессор]]
13. 
14. 

## Глава 1.2. Язык ассемблера

Раздел 1.2 "Язык ассемблера" из предоставленных источников описывает основы языка ассемблера ARM, включая его **команды** и **операнды**.

**Команды**
- Команды языка ассемблера определяют операцию, которую нужно выполнить.
- Для обозначения операций используются **мнемоники**, такие как ADD (сложение) и SUB (вычитание). Мнемоники проще запомнить, чем двоичные коды машинного языка.
- Архитектура ARM использует единообразный формат команд, например, с двумя операндами-источниками и одним операндом-приемником (результатом). Единообразие формата упрощает аппаратную реализацию.
- Более сложный код с языка высокого уровня транслируется в несколько команд ARM.
- Команды могут выполняться **условно** в зависимости от флагов состояния. Условное выполнение команд может быть короче и быстрее, чем использование команд перехода.
- Существуют команды **безусловного перехода** (например, B) и **условного перехода** (например, BEQ - переход по равенству).

**Операнды**
- Команда оперирует данными, которые называются **операндами**.
- Компьютеры работают с двоичными данными.
- Команда должна знать, откуда брать данные. Операнды могут находиться в **регистрах**, **памяти** или быть **константами**.

**Регистры**
- Архитектура ARM определяет 16 регистров.
- Регистры R0–R12 служат для хранения переменных.
- Регистры R0–R3 используются также особым образом при вызове процедур (для аргументов и возвращаемого значения), а также как временные переменные.
- Регистры R4–R11 используются для сохранения переменных.
- R12 является временным регистром.
- R13 называется SP (Stack Pointer - указатель стека).
- R14 называется LR (Link Register - регистр связи) и содержит адрес возврата для вызова функций.
- R15 называется PC (Program Counter - счетчик команд).
- В примерах кода на языке ассемблера ARM регистры используются для хранения переменных и промежуточных результатов, например, R0 = a, R1 = b, R2 = c. Для промежуточных значений могут использоваться временные регистры, такие как R4.
- Архитектура ARM (версия 4, которая рассматривается подробно) является 32-битовой, что означает, что регистры имеют размер 32 бита.

**Константы (непосредственные операнды)**
- Значение константы является частью самой команды, поэтому не требуется доступ к регистрам или памяти для ее получения.
- В ассемблерном коде константы обозначаются знаком **#** перед значением.
- Значение константы может быть записано в десятичном или шестнадцатеричном (с префиксом 0x) виде.
- Непосредственные операнды обычно представляют собой 8- или 12-битовые числа без знака.
- Примеры использования констант: `ADD R7, R7, #4`.
- Команда MOV может использоваться для инициализации регистров непосредственными операндами.

**Память**
- Операнды могут также находиться в памяти.
- Архитектура ARM использует побайтовую адресацию памяти с 32-битовыми адресами.
- Доступ к памяти (загрузка и сохранение данных) осуществляется с помощью специальных команд, таких как LDR (загрузка) и STR (сохранение). (Хотя эти команды подробно рассматриваются в разделе 1.3.6 и далее, концепция памяти как места хранения операндов вводится в разделе 1.2).

В целом, раздел 1.2 закладывает основу для понимания языка ассемблера ARM, вводя ключевые понятия команд, мнемоник, операндов, а также описывая основные типы мест хранения операндов: регистры и константы.

## Глава 1.3. Программирование

- **Трансляция высокоуровневого кода:** Простые операции могут транслироваться в одну команду ассемблера (например, `a = b + c;` в `ADD a, b, c;`), а более сложные конструкции или выражения могут требовать нескольких команд. Использование нескольких команд для сложных операций иллюстрирует **второй принцип хорошего проектирования компьютерной архитектуры: типичный сценарий должен быть быстрым**.
- **Комментарии:** В языке ассемблера ARM используются однострочные комментарии, начинающиеся с символа `;`. В языках высокого уровня, как правило, поддерживаются как однострочные (`//`), так и многострочные (`/* */`) комментарии.
- **Массивы:** Однородные данные могут быть сгруппированы в массивы, которые хранятся в непрерывных участках памяти с последовательными адресами. Доступ к элементам массива по индексу требует масштабирования индекса (умножения на размер элемента, например, на 4 для 32-битовых слов) перед прибавлением к базовому адресу массива. ARM поддерживает адресацию со смещением, а также с предындексацией и постиндексацией для работы с массивами.
- **Функции (Процедуры/Подпрограммы):** Языки высокого уровня поддерживают функции для повторного использования кода, улучшения модульности и удобочитаемости. Функции принимают входные данные (аргументы) и могут возвращать результат (возвращаемое значение).

**Особое внимание в главе уделяется использованию стека при вызовах функций:**
- **Проблема сохранения состояния:** При вызове одной функции из другой вызванная функция может изменить значения регистров, которые требуются вызывающей функции после возврата. Чтобы решить эту проблему, используется стек.
- **Принцип работы стека:** Стек является структурой данных, которая, как правило, **растет вниз** (к меньшим адресам) и работает по принципу **LIFO (Last-In, First-Out)**. Он используется для хранения временных данных, локальных переменных и сохранения состояния регистров.
- **Процесс вызова функции с использованием стека:**
    1. Вызванная функция **выделяет место в стеке**, уменьшая значение указателя стека (SP).
    2. Вызванная функция **сохраняет значения регистров** в выделенное пространство в стеке.
    3. Функция выполняет свои действия, при необходимости изменяя значения регистров.
    4. Перед возвратом функция **восстанавливает исходные значения регистров** из стека.
    5. Вызванная функция **освобождает место в стеке**, увеличивая значение указателя стека (SP) на то же значение, на которое он был уменьшен при входе.
- **Соглашение о регистрах:** Существует стандарт вызова процедур для архитектуры ARM, который определяет, какие регистры являются **оберегаемыми вызываемой функцией (callee-save)** и какие - **оберегаемыми вызывающей функцией (caller-save)**.
    - **Caller-save регистры (R0–R3 и R12):** Вызывающая функция **должна сохранить** эти регистры, если они понадобятся ей после вызова другой функции.
    - **Callee-save регистры (например, R4, R8, R9 в примерах):** Вызываемая функция **должна сохранить** эти регистры, если она планирует их использовать и изменить их значения, чтобы вызывающая функция после возврата обнаружила их в исходном состоянии.
- **Передача аргументов и локальные переменные:** Первые четыре аргумента функции обычно передаются в регистрах R0–R3. Дополнительные аргументы (более четырех) передаются в стеке, и место для них выделяет **вызывающая функция** непосредственно перед указателем стека. Локальные переменные, для которых не хватило регистров, также хранятся в стеке.
- **Адрес возврата:** Регистр R14 (LR, регистр связи) содержит адрес команды, на которую нужно вернуться после выполнения вызова функции (после команды `BL`). Этот адрес также может быть сохранен в стеке, если вызванная функция, в свою очередь, вызывает другую функцию.
- **Стек при обработке исключений:** В ARM предусмотрены отдельные стеки для различных режимов выполнения (например, режим пользователя и режим супервизора). При возникновении исключения процессор переключается на соответствующий стек и сохраняет состояние регистров, чтобы затем вернуться к прерванной программе. Режим быстрого прерывания (FIQ) имеет отдельный банк регистров R8-R12, которые не нужно сохранять в стеке при входе в обработчик, что ускоряет его выполнение.

## Глава 1.4. Машинный язык

- **Команды обработки данных:** Это наиболее распространенный формат команд. 32-битовая команда обработки данных ARM состоит из шести полей: `cond`, `op`, `funct`, `Rn`, `Rd` и `Src2`.
    - Поле `cond` (4 бита, 31:28) кодирует условие выполнения команды в зависимости от флагов состояния. Значение `1110` в этом поле означает безусловное выполнение.
    - Поле `op` (2 бита, 27:26) и поле `funct` (6 бит, 25:20) совместно кодируют выполняемую операцию (мнемонику). Для команд обработки данных поле `op` равно `00`.
    - Поле `Rn` (4 бита, 19:16) указывает первый регистр-источник.
    - Поле `Rd` (4 бита, 15:12) указывает регистр-приемник, куда записывается результат. Важно отметить, что в ассемблерном коде регистр-приемник указывается первым, а в машинной команде ARM он находится во втором регистровом поле (`Rd`).
    - Поле `Src2` (12 бит, 11:0) кодирует второй операнд-источник. Он может быть либо регистром (возможно, сдвинутым), либо непосредственным операндом (константой). Кодирование сдвига (LSL, LSR, ASR, ROR) осуществляется в полях внутри `Src2` при использовании регистра.
- **Команды доступа к памяти:** Команды загрузки (`LDR`) и сохранения (`STR`) слов (`LDR`/`STR`), байтов (`LDRB`/`STRB`), полуслов (`LDRH`/`STRH`) и байтов/полуслов со знаком (`LDRSB`/`LDRSH`) используются для взаимодействия с памятью.
    - Для команд `LDR`, `STR`, `LDRB`, `STRB` (слово/байт) поле `op` равно `01`.
    - Для команд `LDRH`, `STRH`, `LDRSB`, `LDRSH` (полуслово/байт со знаком) поле `op` равно `00`, и они имеют меньшую гибкость в кодировании второго операнда (`Src2`), где непосредственное смещение занимает только 8 бит, а регистровое не может быть сдвинуто.
    - В машинный код команд доступа к памяти также входят биты, управляющие типом индексации (`P`, `W`) и типом операции (`L`, `B`). Например, биты `P` и `W` определяют постиндексацию (`00`), смещение (`10`) или предындексацию (`11`). Биты `L` и `B` определяют `STR` (`00`), `STRB` (`01`), `LDR` (`10`) или `LDRB` (`11`).
- **Команды перехода:** Команды безусловного перехода (`B`) и перехода с сохранением адреса возврата (`BL`) имеют свое машинное представление.
    - Для команд перехода поле `op` равно `10`.
    - Команда `BL` включает 24-битовое поле `imm24`, кодирующее смещение целевого адреса относительно счетчика команд (`PC`), увеличенного на 8 байт (две команды).
- **Режимы адресации:** В машинный код команды доступа к памяти или операнда `Src2` включается информация о режимах адресации. Источники упоминают и показывают примеры кодирования для:
    - **Непосредственного операнда:** Значение константы является частью самой команды. В ассемблере обозначается `#`. Для команд обработки данных константы обычно 8- или 12-битовые. Для доступа к памяти непосредственное смещение может быть до 4095 байт для команд слова/байта. Большие константы и адреса загружаются через пул литералов с использованием `LDR` относительно `PC`.
    - **Регистрового операнда:** Операнды находятся в регистрах.
    - **Смещения:** Адрес вычисляется как сумма базового регистра и непосредственного смещения или смещения из другого регистра.
    - **Масштабированного регистрового смещения:** Индексный регистр масштабируется (сдвигается), а затем прибавляется к базовому адресу. Это полезно для доступа к элементам массива, где смещение равно `индекс * размер_элемента`.
    - **Предындексации и постиндексации:** Эти режимы кодируются битами `P` и `W` в команде доступа к памяти. Они определяют, происходит ли обновление базового регистра _до_ (`!`) или _после_ (`[]`) обращения к памяти.
    - **Адресации относительно счетчика команд (PC):** Используется для команд перехода (`B`, `BL`) и для загрузки констант или адресов из пула литералов.
- **Интерпретация кода на машинном языке:** Чтобы понять машинный код, нужно декодировать поля 32-битового слова команды. Процесс начинается с анализа полей `cond` и `op`.
    - `op = 00` указывает на команду обработки данных. Затем анализируются поля `funct` (включая I-бит) для определения конкретной операции и операндов (`Rn`, `Rd`, `Src2`).
    - `op = 01` указывает на команду доступа к памяти. Анализируются биты `funct` (`B`, `L`) и флаги индексации (`P`, `W`, `I`) для определения операции (`LDR`/`STR`...), режима адресации и операндов (`Rn`, `Rd`, смещение/регистр).
    - `op = 10` указывает на команду перехода. Анализируются соответствующие поля (например, `imm24` для `BL`) для определения цели перехода.

## Глава 1.5. Свет, камера, мотор! Компилируем, ассемблируем и загружаем

- **Компиляция**: Компилятор транслирует программу с языка высокого уровня на язык ассемблера.
- **Ассемблирование**: Ассемблер транслирует ассемблерный код в машинный код и сохраняет результат в объектный файл. Объектный файл можно дизассемблировать, чтобы увидеть ассемблерный код, соответствующий машинному.
- **Компоновка**: Компоновщик объединяет машинный код из объектных файлов с кодом из библиотек и других файлов. Он также вычисляет адреса переходов и переменных, формируя исполняемый файл программы. Компоновщик перемещает данные и команды в объектных файлах так, чтобы они не перекрывались, и использует информацию из таблиц символов для коррекции адресов перемещаемых глобальных переменных и меток. Исполняемый файл содержит обновленную таблицу символов с перемещенными адресами функций и глобальных переменных.
- **Загрузка**: Операционная система загружает программу, считывая сегмент кода из исполняемого файла (обычно с жесткого диска) в сегмент кода в оперативной памяти. Затем операционная система выполняет переход в начало программы, тем самым начиная ее выполнение.
* На практике большинство компиляторов выполняют первые три шага: компиляцию, ассемблирование и компоновку.

**Карта памяти** ARM определяет, где располагаются различные части программы. При запуске программы память обычно делится на несколько сегментов:
- **Сегмент кода** (.text): Содержит машинные команды программы. Этот сегмент считывается из исполняемого файла и загружается в память операционной системой. Машинная программа представляет собой последовательность 32-битовых чисел, представляющих команды, которые могут храниться в памяти.
- **Сегменты данных** (.data, .bss): Содержат данные программы. Например, глобальные переменные могут храниться в этих сегментах. Операнды, с которыми работает команда, могут находиться в памяти. Массивы, например, располагаются в ячейках памяти с последовательными адресами, занимая непрерывный участок памяти.
- **Стек**: Представляет собой область памяти, используемую для хранения локальных переменных функции. Стек расширяется, когда процессору нужно больше места, и сжимается, когда сохраненные там переменные больше не нужны. Дополнительные аргументы функций (сверх первых четырех) и локальные переменные, для которых не хватает регистров, хранятся в стеке. В стеке также хранятся и восстанавливаются регистры, например, регистр связи LR при вызове нелистовых функций. Каждому режиму выполнения может соответствовать свой собственный стек.

## Глава 1.6. Дополнительные сведения

- **1.6.1. Загрузка литералов**    
    - Архитектура ARM использует команды `LDR Rd, =literal` и `LDR Rd, =label` для загрузки 32-битовых констант (literal) или адресов переменных/указателей (label) в регистр Rd.
    - Значение, подлежащее загрузке, хранится в специальной области сегмента кода, называемой **пулом литералов**.
    - Пул литералов должен находиться от команды `LDR` на расстоянии менее 4096 байтов, чтобы загрузку можно было выполнить с помощью команды `LDR Rd, [PC, #offset_to_literal]`, которая использует адресацию относительно счетчика команд (PC).
    - Программа должна обходить пул литералов, поскольку попытка выполнить литерал как команду бессмысленна или хуже.
- **1.6.3. Исключения**
    - При обнаружении исключения процессор выполняет определенную последовательность действий для его обработки:
        1. Сохраняет регистр состояния программы (CPSR) в банке SPSR (Saved Program Status Register).
        2. Устанавливает режим выполнения и уровень привилегий в соответствии с типом исключения.
        3. Устанавливает биты маски прерываний в регистре CPSR, чтобы предотвратить прерывание обработчика исключения.
        4. Сохраняет адрес возврата в регистре связи (LR) в соответствующем банке.
        5. Находит элемент, соответствующий исключению, в таблице векторов исключений.
        6. Загружает адрес обработчика исключения в счетчик команд (PC).
    - После завершения обработки исключения процессор выполняет действия для возврата к прерванной программе, включая:
        1. Восстановление регистров из банка.
        2. Восстановление CPSR из SPSR.
        3. Восстановление режимов выполнения и уровня привилегий.
    - Программы с низким уровнем привилегий (пользовательские программы) используют команду вызова супервизора (`SVC`) для контролируемого переключения на высокий уровень привилегий (для операционной системы), что генерирует исключение. ОС анализирует аргументы, выполняет запрошенную функцию и возвращает управление.
    - Код, работающий с уровнем привилегий PL1 (например, ОС), может получать доступ к регистрам в различных режимах выполнения с помощью команд `MRS` (поместить в регистр из специального регистра) и `MSR` (поместить в специальный регистр из регистра). Эти команды используются, например, на этапе начальной загрузки для инициализации стеков обработчиков исключений.

## Глава 1.7. Эволюция архитектуры ARM

- **Базовая архитектура (до ARMv4)**: Источники упоминают ранние процессоры, такие как ARM1 (1985), и ARM6 (1992) с 4 КБ объединенного кэша. ARMv4 (1993) добавила команды загрузки и сохранения полуслова, а также знаковых байтов и полуслов, сформировав базовый набор команд, рассматриваемый в главе.
- **ARMv4T (например, ARM7TDMI, 1995)**: Введена 16-битовая система команд **Thumb**. Команды Thumb повторяют обычные команды ARM, но с рядом ограничений (меньше доступных регистров, более короткие непосредственные операнды, отсутствие условного выполнения и т.д.). Это позволило увеличить плотность кода, уменьшить размер кода примерно до 65% от эквивалентного кода на полной системе команд ARM, а также использовать более дешевую 16-битовую шину памяти команд и сократить энергопотребление. Процессор ARM7TDMI использовал трехстадийный конвейер.
- **ARMv5TE (например, ARM9E, 1999)**: Добавлены команды для **цифровой обработки сигналов (DSP)** и необязательные команды для **арифметики с плавающей точкой**.
    - **Команды DSP** предназначены для эффективной реализации алгоритмов обработки сигналов, таких как БПФ и фильтры. Ключевой командой является **умножение с накоплением (MAC)** (`sum = sum + src1 × src2`), которая повышает производительность по сравнению с раздельными операциями умножения и сложения. Поддерживаются различные типы данных, включая дробные (Q15, Q31). Добавлены команды `LDRD` и `STRD` для эффективной загрузки/сохранения пар регистров (64-битовых двойных слов).
    - **Команды арифметики с плавающей точкой** обеспечивают большую гибкость для приложений, таких как графика и научные расчеты. В ARMv5TE эти команды были факультативными. Они используют отдельные от основных регистров 64-битовые регистры двойной точности (D0–D15), которые также можно рассматривать как 32-битовые регистры одинарной точности (S0–S31). Определен регистр состояния и управления операций с плавающей точкой (FPSCR).
- **ARMv6 (например, ARM11, 2002)**: Добавлены мультимедийные команды и расширен набор команд Thumb.
- **ARMv7 (например, Cortex-A9, Cortex-A7, Cortex-A15, 2009-2011)**: Усовершенствованы команды для работы с плавающей точкой и мультимедиа, получившие общее название **Advanced SIMD** (Single Instruction, Multiple Data). Команды SIMD позволяют одной команде выполнять операцию над несколькими элементами данных параллельно, что полезно для обработки графики (например, пикселей) и мультимедиа. Названия команд Advanced SIMD начинаются с буквы V. Также определен вариант **ARMv7-M**, поддерживающий только команды Thumb и используемый в небольших микроконтроллерах (например, Cortex-M0+). Регистр CPSR для прикладных программ в ARMv7 стал называться APSR. Процессоры этого поколения использовали более длинные конвейеры (например, 5-стадийный в ARM9E, 8-стадийный в ARM11), а высокопроизводительные ядра (Cortex-A) начали использовать суперскалярность, внеочередное выполнение и переименование регистров.
- **ARMv8 (например, Cortex-A53, Cortex-A57, 2012)**: Представлена совершенно новая **64-битовая архитектура**. Увеличился объем адресуемой памяти, и была переработана структура регистров: счетчик команд (PC) и указатель стека (SP) стали считаться специальными регистрами, отдельными от регистрового файла общего назначения, что упростило реализацию процессора по сравнению с предыдущими версиями, где PC был частью регистрового файла.
- **Стратегия big.LITTLE**: Популярная в мире ARM стратегия для гетерогенных систем, сочетающая более **энергоэффективные ядра** (LITTLE, например, Cortex-A7, Cortex-A53) с ядрами, обеспечивающими **высокую производительность** при пиковых нагрузках (big, например, Cortex-A15, Cortex-A57). Ядра LITTLE обычно проще, с последовательным или попарным выполнением команд, тогда как ядра big - более сложные суперскалярные процессоры с внеочередным выполнением.
- **Эволюция кэш-памяти**: Параллельно с архитектурой развивалась организация кэш-памяти в процессорах ARM. Основные тенденции включали введение нескольких уровней кэша (L1, L2), увеличение их емкости и разделение кэша первого уровня (L1) на отдельные кэши для команд и данных. Это было обусловлено растущим разрывом в скорости между процессорами и оперативной памятью, а также снижением стоимости транзисторов, что позволяло добавлять на кристалл более крупные кэши.

## Глава 1.8. Живой пример: архитектура х86

- **Историческое развитие и характер архитектуры** Архитектура x86 эволюционировала на протяжении многих лет путем добавления новых команд и возможностей, что привело к менее элегантному дизайну по сравнению с ARM, содержащему множество "странностей" и являющемуся "эклектичной смесью разнородных решений". Некоторые из этих решений давно бесполезны, но сохранены ради обратной совместимости.
- **Рыночная доминация** Несмотря на технические недостатки, архитектура x86 стала стандартом де-факто для персональных компьютеров благодаря критической важности совместимости программного обеспечения. Огромный рынок оправдывает ежегодные многомиллиардные инвестиции в улучшение этих процессоров.
- **Основные отличия от ARM (согласно Табл. 1.19):**
    - **Регистры:** Архитектура x86 имеет меньше регистров общего назначения (8 против 15 у ARM), причем некоторые из них имеют ограничения по использованию. Регистры развивались от 16-битовых (в 8086) до 32-битовых (EAX, ECX и т.д. в 80386) с сохранением доступа к младшим частям. В начале 2000-х годов x86 была расширена до 64-битной (AMD64, EM64T), увеличив размер регистров и объем адресуемой памяти.
    - **Операнды:** Команды x86 обычно имеют два операнда (один источник и один одновременно источник/приемник), тогда как команды ARM чаще используют три или четыре. В результате команда x86 всегда записывает результат на место одного из операндов.
    - **Расположение операндов:** В отличие от ARM, где команды работают только с регистрами и непосредственными операндами (требуя явных команд загрузки/сохранения для работы с памятью), команды x86 могут работать напрямую с операндами, находящимися в памяти. Возможны различные комбинации расположения операндов (регистр-регистр, регистр-непосредственный, регистр-память, память-регистр, память-непосредственный), кроме память-память.
    - **Размер операндов:** В x86 можно использовать данные размером 8, 16 или 32 бита. Для выбора размера операндов может использоваться код операции или специальные префиксы, например 0x66. Впоследствии добавлена поддержка 64-битовых операндов.
    - **Флаги состояния:** Как и ARM, x86 использует флаги условий (состояния) для ветвлений и отслеживания результатов операций; они хранятся в регистре EFLAGS.
    - **Типы команд:** x86 включает как простые, так и сложные команды. Сложные команды могут быть эквивалентны нескольким простым командам ARM.
    - **Размер команд и кодирование:** Команды x86 имеют переменную длину от 1 до 15 байтов. Система кодирования команд очень запутана и обременена историческим наследием. Часто используемые команды имеют меньший размер. Декодирование команд x86 сложнее, чем в ARM.
    - **Режимы адресации памяти:** x86 поддерживает больше различных режимов индексирования памяти, включая масштабируемый индексный регистр, что упрощает доступ к элементам массивов и структур.
    - **Команды обработки строк:** Существуют специальные команды для работы со строками байтов или слов (копирование, сравнение, поиск), хотя на современных процессорах они могут работать медленнее последовательности простых команд.
- **Переход к 64 битам:** Ограничение в 4 ГБ адресуемой памяти в 32-битовой архитектуре стало существенным. В начале 2000-х годов AMD и затем Intel представили 64-битовые расширения (AMD64, EM64T), увеличившие адресное пространство до 16 экзабайт и разрядность регистров. Была сохранена совместимость для запуска 32-битовых программ.

## Глава 1.9. Резюме

Чтобы командовать компьютером, нужно разговаривать на его языке. Архитектура компьютера определяет, как именно нужно это делать. На сегодняшний день в мире существует много коммерчески используемых архитектур, но если вы хорошо понимаете одну из них, то изучить дру- гие гораздо проще. При изучении новой архитектуры следует задать себе следующие главные вопросы: 
* Какова длина слова данных?
* Какие есть регистры?
* *Как организована память?
* Какие есть команды?
Архитектура ARM является 32-битовой, потому что работает с 32-битовыми данными. В архитектуре ARM определено 16 регистров: 15 регист­ ров общего назначения и счетчик команд. В принципе, любой регистр общего назначения можно использовать для любой цели. Однако существуют соглашения, по которым определенные регистры зарезерви- рованы для конкретных целей. Это сделано для того, чтобы облегчить процесс программирования и чтобы функции, написанные разными про- граммистами, могли легко между собой взаимодействовать. Например, регистр R14 (регистр связи LR) всегда содержит адрес возврата после выполнения команды BL, а в регистрах R0–R3 хранятся аргументы функ- ции. В архитектуре ARM применяются побайтовая адресация памяти и 32-битовые адреса. Длина каждой команды 32 бита, и все команды вы- ровнены по границе 4-байтового слова. В этой главе мы обсудили наибо- лее часто используемые команды ARM. 
ARM выдерживает баланс между простыми командами и плотным кодом путем включения таких возможностей, как флаги условий и сдвиг регистровых операндов. Благодаря им код, написанный для ARM, оказывается более компактным, чем в других RISC-архитектурах. 104 Глава 1. Архитектура Важность определения компьютерной архитектуры заключается в том, что программа, написанная для выбранной архитектуры, будет ра- ботать на совершенно разных реализациях этой архитектуры. Например, программы, написанные для процессора Intel Pentium в 1993 году, вооб- ще говоря, будут работать (причем работать значительно быстрее) и на процессорах Intel Xeon или AMD Phenom в 2015 году.

## Глава 2.1. Введение

* Глава 2 ставит своей целью **собрать три различные версии микропроцессора**, отличающиеся по соотношению этих характеристик.
* ***Процесс проектирования**: Проектирование микроархитектуры делится на две взаимодействующие части:
	- **Тракт данных:** Работает со словами данных и включает в себя такие блоки, как память, регистры, АЛУ и мультиплексоры. Для 32-битной архитектуры, такой как ARM, используется 32-битовый тракт данных.
	- **Устройство управления:** Получает текущую команду из тракта данных и генерирует необходимые управляющие сигналы, определяя, как именно тракт данных должен выполнить эту команду. Микропроцессор строится из тактируемых элементов состояния и комбинационной логики, являясь синхронной последовательной схемой. Процессор можно рассматривать как гигантский конечный автомат или набор взаимодействующих конечных автоматов.
* ***Микроархитектуры**, которые будут разработаны в главе 2: В этой главе будут разработаны три различные микроархитектуры для архитектуры процессора ARM, различающиеся способом соединения элементов состояния и объемом неархитектурного состояния:
	- **Однотактная микроархитектура:** Вся команда выполняется за **один такт**. Принцип работы прост, устройство управления довольно простое, не требует неархитектурного состояния. **Недостаток**: длительность такта ограничена самой медленной командой. Требует раздельной памяти для команд и данных, что обычно нереально.
	- **Многотактная микроархитектура:** Команда выполняется за **несколько более коротких тактов**. Простые команды требуют меньше тактов. Уменьшает количество необходимого оборудования за счет повторного использования дорогих блоков (например, сумматоров, блоков памяти), требуя для этого нескольких неархитектурных регистров для хранения промежуточных результатов. Выполняет только одну команду за раз, но каждая команда занимает несколько тактов. Требует только одну память для команд и данных, обращаясь к ней на разных тактах. Исторически использовалась в недорогих системах.
	- **Конвейерная микроархитектура:** Результат применения конвейерной обработки к однотактной микроархитектуре, делящая выполнение команды на **пять стадий** (Выборка, Декодирование, Выполнение, Доступ к памяти, Запись результатов). Позволяет **одновременно выполнять несколько команд** (по одной на каждой стадии), что значительно улучшает пропускную способность процессора. Тактовая частота может быть значительно выше, так как каждая стадия содержит меньше логики. Требует дополнительной логики для разрешения конфликтов между одновременно выполняющимися командами и нескольких неархитектурных регистров между стадиями. Обычно использует раздельные кэши команд и данных. Несмотря на накладные расходы, конвейеризация обеспечивает существенное увеличение производительности и **используется во всех современных высокопроизводительных микропроцессорах**.

## Глава 2.2. Анализ производительности

- Отмечается, что для каждой процессорной архитектуры может существовать множество микроархитектур, предлагающих разное соотношение цены и производительности. **Цена** микропроцессора зависит от **количества логических элементов и памяти**, а также от технологии производства. В целом, чем больше логических вентилей и памяти, тем выше цена.
- В разделе говорится, что производительность системы можно измерять различными способами. Маркетологи часто используют в рекламе такие метрики, как **тактовая частота и количество процессорных ядер**, но эти показатели не всегда отражают реальную производительность для конкретной программы. Они не учитывают, что разные процессоры могут выполнять разный объем работы за один такт, и что эта характеристика зависит от программы.
- **Единственным по-настоящему честным способом узнать производительность компьютера** является **измерение времени выполнения интересующей вас программы**. Чем быстрее компьютер выполняет программу, тем выше его производительность. Хорошим подходом также считается измерение времени выполнения **нескольких программ, похожих на те, которые планируется запускать**. Такие программы называются **эталонными тестами (benchmark)**, и полученные времена выполнения обычно публикуются.
- В качестве примера широко используемого эталонного теста для оценки высокопроизводительных процессоров приводится **SPEC CINT2006**, который включает реальные программы (например, h264ref, sjeng, hmmer, gcc). Этот тест нагружает все компоненты ЦП способами, характерными для настоящих программ.

## Глава 2.3. Однотактный процессор

- **Принцип работы:** Вся команда, от выборки до записи результата, выполняется в рамках одного такта. Это означает, что показатель CPI (число тактов на команду) для него равен 1.
- **Процесс проектирования:** Проектирование начинается с конструирования тракта данных, который работает со словами данных и включает элементы состояния, такие как память, регистры, АЛУ и мультиплексоры, соединенные комбинационной логикой. Управляющие сигналы определяют, как тракт данных выполняет текущую команду.
- **Тракт данных:** Для его реализации необходима раздельная память для команд и данных, поскольку выборка команды и доступ к данным (чтение или запись) должны происходить в одном и том же такте. Также в тракте данных однотактного процессора требуется несколько сумматоров (например, три: один для АЛУ и два для вычисления следующего значения счетчика команд). Процесс проектирования предполагает поэтапное добавление компонентов для поддержки различных команд, начиная с простых, вроде LDR. Добавление поддержки некоторых команд или режимов адресации может потребовать добавления аппаратных блоков, например, сдвигового регистра перед АЛУ для поддержки сдвинутых регистров. Тракт данных однотактного процессора для архитектуры ARM является 32-битовым.
- **Устройство управления:** Устройство управления (Control Unit) отвечает за формирование управляющих сигналов, которые настраивают тракт данных на выполнение конкретной команды. Оно основано на комбинационной логике и формирует сигналы в зависимости от полей команды (cond, op, funct) и флагов состояния. Устройство управления также хранит и обновляет флаги состояния.
- **Представление на языке HDL:** HDL-код (Hardware Description Language) для однотактного процессора, поддерживающего рассмотренные команды, может служить примером при описании цифровых систем. В этом представлении память команд и данных отделены и подсоединены к тракту данных с помощью шин адреса и данных.
- **Анализ производительности:** Время выполнения программы вычисляется по формуле, связывающей число команд, число тактов на команду (CPI) и период тактового сигнала (Tc). Поскольку CPI однотактного процессора равен 1, его производительность сильно зависит от длительности такта (Tc). Длительность такта ограничена самым долгим путем прохождения сигнала через комбинационную логику (критический путь), который определяется самой медленной командой, такой как LDR. Источники приводят формулы для расчета Tc, учитывающие задержки различных элементов, таких как регистры, мультиплексоры, АЛУ, память и декодеры.
- **Недостатки:** У однотактного процессора есть три основные проблемы:
    1. Требуется отдельная память для команд и данных.
    2. Период тактового сигнала должен быть достаточно большим для выполнения самой медленной команды, даже если большинство команд выполняется гораздо быстрее.
    3. Требуется несколько сумматоров, которые являются относительно дорогими блоками.

**Команда LDR (загрузка из памяти в регистр)**
![[ldr-single-cycle-processor-datapath.png]]

Эта реализация поддерживает только загрузку из памяти данных: `LDR Rd, [Rn, #imm]`
где
- `Rd` — регистр‑приёмник R0-R15 (куда загрузим данные)
- `Rn` — базовый регистр R0-R15 (откуда берём базовый адрес)
- `#imm` — (опционально) беззнаковое смещение в байтах

1. Из `PC` (Program Counter) подается адрес команды в порт A `Память команд` 
2. Из выхода RD `Память команд` читается 32 битная команда `Instr`
3. Выходы из `Память команд` идут на вход `Регистровый файл`, где:
	1. `A1` - адрес регистра, который хранит адрес ячейки `Память данных`
	2. `A3` - адрес регистра, куда загрузить данные
	3. `imm` - смещение для адреса ячейки `Память данных`
4. Далее адрес ячейки `Память данных` на выходе `RD1`, `imm` дополняется до 32 бит и идет на выход `Дополнение` `ExtImm`
5. Через `АЛУ` (Арифметико-логическое устройство) складываем смещение `imm` (вход `АЛУ SrcB`) и адрес ячейки (вход `АЛУ SrcA`) `Память данных`
6. Далее читаем данные из `Память данных` по адресу входа `A`, данные на выходе `ReadData`
7. Данные `ReadData` идут на вход `Регистровый файл WD3` и записываются в регистр по адресу на входе `A3`
8. Далее обновляем `PC` на следующую команду, прибавляем 4 через `Сумматор/АЛУ`, тк у нас 32 битная система с побайтовой адресацией и передаем на вход `PC'`
9. Регистр R15 исключение по спецификации, он всегда должен возвращать `PC`+8, поэтому добавляем еще один `Сумматор/АЛУ`

На входы `PCSrc, RegWrite/WE3, ALUControl, WE, `подаются значения из `устройство управления`, которое будет дальше.

**Команда STR (загрузка из регистра в память)**
![[str-single-cycle-processor-datapath.png]]

1. Читаем команду из `Память данных` по адресу `PC`
2. На `A1` идет адрес регистра, который содержит адрес `Память данных` для записи, на `A2` идет адрес регистра, который содержит данные для записи
3. Складываем смещение с базовым адресом для записи в `АЛУ`
4. Выход `RD2` с данными для записи идет на вход `WD Память данных`, а результат `АЛУ` - адрес для записи на вход `A Память данных`
5. Далее обновление `PC`

Важно отметить, что в `Регистровый файл` вход `RegWrite = 0`, а в `Память данных` вход `MemWrite = 1`.

**Команды обработки данных с непосредственной адресацией**
![[data-process-commands-scalar-value-single-cycle-processor-datapath.png]]

Текущем оборудованием может выполнять и команды ADD, SUB, AND, ORR в режиме непосредственной адресации (когда мы передаем аргумент как есть, например #10 или 0xFFFFF).
Различие только в сигнале ALUControl, который определяет какую операцию выполнить.
Как и в случае команды LDR, тракт данных читает первый операнд-источник из порта 1 регистрового файла и дополняет нулями непосредственный операнд, находящийся в младших битах Instr. Однако для команд обработки данных используется только 8-битовый, а не 12-битовый непосредственный операнд. Поэтому мы подаем управ- ляющий сигнал ImmSrc блоку дополнения. Если этот сигнал равен 0, то ExtImm получается расширением нулями поля Instr7:0 – для команд обработки данных. А если 1, то ExtImm получается расширением нулями поля Instr11:0 – для команд LDR и STR.
Для команды LDR порт записи регистрового файла был всегда подключен к памяти данных. Однако команды обработки данных записывают в регистровый файл значение ALUResult. Чтобы выбирать между ReadData и ALUResult, мы добавляем еще один мультиплексор, выход которого назовем Result. Этот мультиплексор управляется еще одним новым сигналом, MemtoReg. Сигнал MemtoReg равен 0 для команд обработки данных – в этом случае Result принимает значение ALUResult. Для команды LDR сигнал MemtoReg равен 1, а Result принимает значе- ние ReadData. Для команды STR значение MemtoReg не играет никакой роли, так как она ничего в регистровый файл не пишет.

**Команды обработки данных с регистровой адресацией**
![[data-process-commands-register-value-single-cycle-processor-datapath.png]]
Команды обработки данных с регистровой адресацией получают второй операнд-источник из поля Rm (Instr3:0), а не из непосредственного операнда. Поэтому мы добавляем на входах в регистровый файл и в АЛУ мультиплексоры, выбирающие второй операнд-источник (см. Рис 2.11).
RA2 берется из поля Rd (Instr15:12) для команды STR или из поля Rm (Instr3:0) для команд обработки данных с регистровой адресацией в зависимости от управляющего сигнала RegSrc. Аналогично в зависимости от управляющего сигнала ALUSrc второй вход в АЛУ выбирается из ExtImm для команд с непосредственным операндом или из регистрового файла для команд обработки данных с регистровой адресацией.

ARM‑инструкция обработки данных (Data‑Processing) имеет несколько полей, из которых нас интересуют:

| Поле       | Биты                       | Содержит                                                                   |
| ---------- | -------------------------- | -------------------------------------------------------------------------- |
| Rd         | Instr[15:12]               | Номер регистра‑приёмника (destination)                                     |
| Rn         | Instr[19:16]               | Номер первого операнда (source 1)                                          |
| Rm / imm12 | Instr[3:0] или Instr[11:0] | Второй операнд — либо регистр Rm, либо 12‑битное непосредственное значение |
- **Для команд с непосредственным операндом** используется поле `Instr[11:0]` → zero‑extend → 32‑битный Imm.
- **Для команд с регистровым операндом** используется поле `Instr[3:0]` → это номер регистра Rm.

**Команда B (безусловный переход)**
![[b-command-single-cycle-processor-datapath.png]]

Команда B (Branch) в ARM — это безусловный переход: она меняет PC на новое значение, вместо PC+4. В микроархитектуре мы должны:
1. Считать из регфайла не обычный Rn, а PC+8
2. Взять 24‑битный signed immediate, умножить его на 4
3. Сложить с (PC+8) → новый PC
4. Записать в PC

**Однотактное устройство управления**

## Глава 2.4. Многотактный процессор


[Книга](https://www.labirint.ru/books/662585/)

1. [[#Глава 1.2. Язык ассемблера]]
2. [[#Глава 1.3. Программирование]]
3. [[#Глава 1.4. Машинный язык]]
4. 
## Глава 1.2. Язык ассемблера

Раздел 1.2 "Язык ассемблера" из предоставленных источников описывает основы языка ассемблера ARM, включая его **команды** и **операнды**.

**Команды**
- Команды языка ассемблера определяют операцию, которую нужно выполнить.
- Для обозначения операций используются **мнемоники**, такие как ADD (сложение) и SUB (вычитание). Мнемоники проще запомнить, чем двоичные коды машинного языка.
- Архитектура ARM использует единообразный формат команд, например, с двумя операндами-источниками и одним операндом-приемником (результатом). Единообразие формата упрощает аппаратную реализацию.
- Более сложный код с языка высокого уровня транслируется в несколько команд ARM.
- Команды могут выполняться **условно** в зависимости от флагов состояния. Условное выполнение команд может быть короче и быстрее, чем использование команд перехода.
- Существуют команды **безусловного перехода** (например, B) и **условного перехода** (например, BEQ - переход по равенству).

**Операнды**
- Команда оперирует данными, которые называются **операндами**.
- Компьютеры работают с двоичными данными.
- Команда должна знать, откуда брать данные. Операнды могут находиться в **регистрах**, **памяти** или быть **константами**.

**Регистры**
- Архитектура ARM определяет 16 регистров.
- Регистры R0–R12 служат для хранения переменных.
- Регистры R0–R3 используются также особым образом при вызове процедур (для аргументов и возвращаемого значения), а также как временные переменные.
- Регистры R4–R11 используются для сохранения переменных.
- R12 является временным регистром.
- R13 называется SP (Stack Pointer - указатель стека).
- R14 называется LR (Link Register - регистр связи) и содержит адрес возврата для вызова функций.
- R15 называется PC (Program Counter - счетчик команд).
- В примерах кода на языке ассемблера ARM регистры используются для хранения переменных и промежуточных результатов, например, R0 = a, R1 = b, R2 = c. Для промежуточных значений могут использоваться временные регистры, такие как R4.
- Архитектура ARM (версия 4, которая рассматривается подробно) является 32-битовой, что означает, что регистры имеют размер 32 бита.

**Константы (непосредственные операнды)**
- Значение константы является частью самой команды, поэтому не требуется доступ к регистрам или памяти для ее получения.
- В ассемблерном коде константы обозначаются знаком **#** перед значением.
- Значение константы может быть записано в десятичном или шестнадцатеричном (с префиксом 0x) виде.
- Непосредственные операнды обычно представляют собой 8- или 12-битовые числа без знака.
- Примеры использования констант: `ADD R7, R7, #4`.
- Команда MOV может использоваться для инициализации регистров непосредственными операндами.

**Память**
- Операнды могут также находиться в памяти.
- Архитектура ARM использует побайтовую адресацию памяти с 32-битовыми адресами.
- Доступ к памяти (загрузка и сохранение данных) осуществляется с помощью специальных команд, таких как LDR (загрузка) и STR (сохранение). (Хотя эти команды подробно рассматриваются в разделе 1.3.6 и далее, концепция памяти как места хранения операндов вводится в разделе 1.2).

В целом, раздел 1.2 закладывает основу для понимания языка ассемблера ARM, вводя ключевые понятия команд, мнемоник, операндов, а также описывая основные типы мест хранения операндов: регистры и константы.

## Глава 1.3. Программирование

- **Трансляция высокоуровневого кода:** Простые операции могут транслироваться в одну команду ассемблера (например, `a = b + c;` в `ADD a, b, c;`), а более сложные конструкции или выражения могут требовать нескольких команд. Использование нескольких команд для сложных операций иллюстрирует **второй принцип хорошего проектирования компьютерной архитектуры: типичный сценарий должен быть быстрым**.
- **Комментарии:** В языке ассемблера ARM используются однострочные комментарии, начинающиеся с символа `;`. В языках высокого уровня, как правило, поддерживаются как однострочные (`//`), так и многострочные (`/* */`) комментарии.
- **Массивы:** Однородные данные могут быть сгруппированы в массивы, которые хранятся в непрерывных участках памяти с последовательными адресами. Доступ к элементам массива по индексу требует масштабирования индекса (умножения на размер элемента, например, на 4 для 32-битовых слов) перед прибавлением к базовому адресу массива. ARM поддерживает адресацию со смещением, а также с предындексацией и постиндексацией для работы с массивами.
- **Функции (Процедуры/Подпрограммы):** Языки высокого уровня поддерживают функции для повторного использования кода, улучшения модульности и удобочитаемости. Функции принимают входные данные (аргументы) и могут возвращать результат (возвращаемое значение).

**Особое внимание в главе уделяется использованию стека при вызовах функций:**
- **Проблема сохранения состояния:** При вызове одной функции из другой вызванная функция может изменить значения регистров, которые требуются вызывающей функции после возврата. Чтобы решить эту проблему, используется стек.
- **Принцип работы стека:** Стек является структурой данных, которая, как правило, **растет вниз** (к меньшим адресам) и работает по принципу **LIFO (Last-In, First-Out)**. Он используется для хранения временных данных, локальных переменных и сохранения состояния регистров.
- **Процесс вызова функции с использованием стека:**
    1. Вызванная функция **выделяет место в стеке**, уменьшая значение указателя стека (SP).
    2. Вызванная функция **сохраняет значения регистров** в выделенное пространство в стеке.
    3. Функция выполняет свои действия, при необходимости изменяя значения регистров.
    4. Перед возвратом функция **восстанавливает исходные значения регистров** из стека.
    5. Вызванная функция **освобождает место в стеке**, увеличивая значение указателя стека (SP) на то же значение, на которое он был уменьшен при входе.
- **Соглашение о регистрах:** Существует стандарт вызова процедур для архитектуры ARM, который определяет, какие регистры являются **оберегаемыми вызываемой функцией (callee-save)** и какие - **оберегаемыми вызывающей функцией (caller-save)**.
    - **Caller-save регистры (R0–R3 и R12):** Вызывающая функция **должна сохранить** эти регистры, если они понадобятся ей после вызова другой функции.
    - **Callee-save регистры (например, R4, R8, R9 в примерах):** Вызываемая функция **должна сохранить** эти регистры, если она планирует их использовать и изменить их значения, чтобы вызывающая функция после возврата обнаружила их в исходном состоянии.
- **Передача аргументов и локальные переменные:** Первые четыре аргумента функции обычно передаются в регистрах R0–R3. Дополнительные аргументы (более четырех) передаются в стеке, и место для них выделяет **вызывающая функция** непосредственно перед указателем стека. Локальные переменные, для которых не хватило регистров, также хранятся в стеке.
- **Адрес возврата:** Регистр R14 (LR, регистр связи) содержит адрес команды, на которую нужно вернуться после выполнения вызова функции (после команды `BL`). Этот адрес также может быть сохранен в стеке, если вызванная функция, в свою очередь, вызывает другую функцию.
- **Стек при обработке исключений:** В ARM предусмотрены отдельные стеки для различных режимов выполнения (например, режим пользователя и режим супервизора). При возникновении исключения процессор переключается на соответствующий стек и сохраняет состояние регистров, чтобы затем вернуться к прерванной программе. Режим быстрого прерывания (FIQ) имеет отдельный банк регистров R8-R12, которые не нужно сохранять в стеке при входе в обработчик, что ускоряет его выполнение.

## Глава 1.4. Машинный язык


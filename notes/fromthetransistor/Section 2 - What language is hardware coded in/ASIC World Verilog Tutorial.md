https://www.asic-world.com/verilog/

1. [[#Introduction]]
2. [[#Verilog In One Day Part-I (modules, data types, operators)]]
3. [[#Verilog In One Day Part-II (Control Statements, Variable Assignment)]]
4. [[#Verilog In One Day Part-III (always blocks, assign statement, task and function)]]
5. [[#Verilog In One Day Part-IV (Test Benches)]]
6. [[#History Of Verilog]]
7. 

## Introduction

Verilog — это **Язык Описания Аппаратных Средств (HDL)**. Язык описания аппаратных средств используется для описания цифровой системы, такой как сетевой коммутатор, микропроцессор, память или простой триггер. Это означает, что с помощью HDL можно описать любое цифровое аппаратное обеспечение на любом уровне.

Verilog поддерживает проектирование на многих различных уровнях абстракции. Три из них являются очень важными: **Поведенческий уровень (Behavioral level)**, **Уровень Регистровых Передач (Register-Transfer Level - RTL)** и **Вентильный уровень (Gate Level)**.

- На **Поведенческом уровне** система описывается с помощью параллельных алгоритмов. Каждый алгоритм сам по себе является последовательным и состоит из набора инструкций, выполняемых одна за другой. Основными элементами являются функции (Functions), задачи (Tasks) и блоки `always`. На этом уровне нет учета структурной реализации проекта.
- На **Уровне Регистровых Передач (RTL)** характеристики схемы определяются операциями и передачей данных между регистрами. Используется явный тактовый сигнал. RTL проектирование содержит точные временные границы: операции планируются к выполнению в определенное время. Современное определение RTL кода — "любой синтезируемый код называется RTL кодом".
- На **Вентильном уровне (Gate Level)** характеристики системы описываются логическими связями и их временными свойствами. Все сигналы являются дискретными и могут принимать только определенные логические значения (`0`, `1`, `X`, `Z`). Используемые операции — предопределенные логические примитивы (вентили AND, OR, NOT и т.д.). Использование вентильного моделирования может быть не лучшей идеей для любого уровня логического проектирования; код на вентильном уровне обычно генерируется инструментами синтеза и используется для симуляции на вентильном уровне и для бэкенда.

Verilog, как и любой другой язык описания аппаратных средств, допускает проектирование как по методологии **снизу-вверх (Bottom-up)**, так и **сверху-вниз (Top-down)**. Традиционный метод снизу-вверх, выполняемый на уровне вентилей, становится почти невозможным при возрастающей сложности новых проектов. Желаемым стилем проектирования является метод сверху-вниз, который обеспечивает раннее тестирование, легкую смену технологий и структурированное проектирование. Из-за трудностей полного следования чистому методу сверху-вниз, большинство проектов представляют собой смешение обоих подходов.

## Verilog In One Day Part-I (modules, data types, operators)

Жизнь до появления Verilog была наполнена схемами (schematics). Каждое проектирование, независимо от сложности, выполнялось с помощью схем. Их было сложно верифицировать и они были склонны к ошибкам, что приводило к долгим, утомительным циклам разработки, верификации и повторения.

С приходом Verilog появился **новый способ мышления** о логических схемах. Цикл проектирования с использованием Verilog **более похож на традиционный цикл программирования**. Типичный цикл проектирования в Verilog включает следующие этапы:

- **Спецификации (specs)**: Определение ограничений и требований к проекту, а также того, что именно мы пытаемся построить.
- Высокоуровневое проектирование (High level design).
- Низкоуровневое (микро) проектирование (Low level (micro) design).
- **RTL-кодирование (RTL coding)**: Написание кода Verilog на уровне регистровых передач.
- **Верификация (Verification)**: Проверка правильности работы проекта.
- **Синтез (Synthesis)**: Преобразование кода Verilog в физическую реализацию схемы (например, набор вентилей).

Традиционные методы проектирования с использованием конечных автоматов, таблиц истинности, карт Карно и получения оптимизированных схем хорошо работают для небольших проектов, но становятся сложными и подверженными ошибкам для больших дизайнов. Verilog предлагает альтернативный подход.

В Verilog концепция "черных ящиков" или блоков, имеющих входы, выходы и внутреннюю логику, называется **"модулем" (module)**. Это зарезервированное слово в языке. Модули являются аналогами функций с возвращаемыми значениями в других языках программирования.

В модуле определяются **порты (ports)**, которые могут быть **входными (input)**, **выходными (output)** или **двунаправленными (inout)**. Двунаправленные порты используются для сигналов, которые могут передавать данные в обоих направлениях. Можно также определять **векторные сигналы** (состоящие из более чем одного бита), указывая диапазон бит, например, `[7:0]` для 8-битного сигнала. При этом важно выбрать и последовательно использовать соглашение о порядке бит (endianness).

В Verilog существуют фундаментальные **типы данных**, связанные с аппаратной природой проектирования. Есть два основных типа "драйверов" (объектов, способных управлять нагрузкой):

- Драйвер, который **может хранить значение** (например, триггер). В Verilog этот тип называется **`reg`** (сокращение от register). Тип `reg` используется для хранения значений.
- Драйвер, который **не может хранить значение**, а лишь соединяет две точки (например, провод). В Verilog этот тип называется **`wire`** (для "провода"). Тип `wire` используется для соединения двух точек.

Раздел также обсуждает **операторы (operators)** в Verilog. Операторы во многом **схожи с операторами в языке программирования C**, выполняя арифметические, логические, реляционные операции, операции сравнения, редукции, сдвига, конкатенации и условные операции.

## Verilog In One Day Part-II (Control Statements, Variable Assignment)

1. **Операторы управления**: Verilog включает операторы управления, которые **выглядят так же, как в языке C** (например, `if`, `else`, `repeat`, `while`, `for`, `case`). Однако, поскольку Verilog является Языком Описания Аппаратных Средств (HDL), эти операторы должны транслироваться в аппаратное обеспечение. Поэтому необходимо быть осторожным при их использовании, чтобы дизайн был реализуем в "железе".
2. **`if-else`**: Используется для проверки условия и условного выполнения блока кода. Можно использовать любые операторы для проверки условия, как в C. Допускается вложенность `if-else`. **Важное замечание**: при моделировании комбинационной логики, если не покрыты все случаи (нет блока `else`), это может привести к синтезу **защелки (Latch)**.
3. **`case`**: Используется, когда одна переменная должна быть проверена на соответствие нескольким значениям, подобно оператору `switch` в C++. Начинается с `case`, заканчивается `endcase`. Случаи указываются со знаком двоеточия. **Настоятельно рекомендуется включать `default` случай**, чтобы предотвратить "зависание" конечного автомата (FSM), если входное значение не соответствует ни одному из описанных случаев. Как и в `if-else`, отсутствие покрытия всех случаев (включая `default`) при моделировании комбинационной логики приведет к синтезу **защелки**.
4. **`while`**: Повторно выполняет код до тех пор, пока условие истинно. Обычно используется **не для моделирования аппаратного обеспечения**, а в **тестбенчах** (test benches). Блоки `while`, как и другие блоки операторов, заключаются в `begin` и `end`.
5. **`always` блок**: Вводится как ключевая особенность Verilog. В отличие от большинства языков программирования, которые выполняются **последовательно**, Verilog допускает **параллельное выполнение** множества блоков кода. Блоки `always` выполняются **одновременно**, когда срабатывает одно или несколько условий, указанных в списке чувствительности после символа `@`. Примером условия может быть **положительный фронт тактового сигнала** (`posedge clk`) или сброса (`posedge rst`). Может быть несколько блоков `always` в одной программе, выполняющихся параллельно.
6. **`disable`**: Зарезервированное слово, используемое для отключения блока кода.
7. **`for` цикл**: Почти идентичен циклам `for` в C/C++. **Единственное отличие** в том, что операторы `++` и `--` не поддерживаются; вместо `i++` нужно писать `i = i + 1`. При использовании `for` циклов для RTL нужно убедиться, что код реализуем в аппаратном обеспечении и что цикл не является бесконечным.
8. **`repeat`**: Сходен с `for` циклом, но указывает фиксированное число повторений. Переменные не инкрементируются автоматически, если это не указано явно. Относительно редко используется для фактической реализации аппаратного обеспечения.
9. **Моделирование элементов**: Verilog предоставляет способы моделирования двух типов цифровых элементов: **комбинационных** и **последовательных**.
    - Комбинационные элементы могут быть смоделированы с использованием операторов `assign` и `always`.
    - Последовательные элементы могут быть смоделированы **только** с использованием оператора `always`.
10. **`initial` блок**: Третий тип блока, используемый **исключительно в тестбенчах**. Выполняется только **один раз** в самом начале симуляции (в момент времени 0). Если есть несколько `initial` блоков, все они выполняются одновременно в начале симуляции. Используется для инициализации переменных в тестбенчах.

## Verilog In One Day Part-III (always blocks, assign statement, task and function)

- **Always Blocks (Блоки `always`)**: В отличие от блоков `initial`, которые выполняются только один раз в начале симуляции, блоки `always` выполняются **всегда**. Блок `always` должен иметь либо **список чувствительности (sensitive list)**, либо **задержку**. Список чувствительности указывает, когда именно должен выполниться код внутри блока. Символ `@` после зарезервированного слова `always` указывает, что блок будет запущен при выполнении условия в скобках.
    - **Важное ограничение**: Блок `always` **не может управлять типом данных `wire`**, он может управлять только типами данных `reg` и `integer`.
    - Для моделирования комбинационной логики список чувствительности должен включать все входные переменные (или переменные, управляющие выходом), изменение которых должно вызывать выполнение блока. Существуют два типа списков чувствительности: **уровнево-чувствительные (level sensitive)** для комбинационных схем и **чувствительные к фронту (edge sensitive)** для триггеров. Примером чувствительности к фронту является `@ (posedge clk)`, что означает выполнение при положительном фронте тактового сигнала.
    - В блоках `always` используются два оператора присваивания: **блокирующее присваивание (`=`)** и **неблокирующее присваивание (`<=`)**. Блокирующее присваивание выполняет код **последовательно** внутри блока `begin`/`end`, тогда как неблокирующее присваивание выполняется **параллельно**. Для моделирования последовательных элементов (триггеров) в чувствительных к фронту блоках `always` необходимо использовать **неблокирующее присваивание (`<=`)**.
    - Блок `always` может существовать без списка чувствительности, но в этом случае он должен содержать **задержку** (например, `#5`). Такие блоки часто используются для генерации сигналов, например, тактового, в тестбенчах.
- **Assign Statement (Оператор `assign`)**: Оператор `assign` используется **только для моделирования комбинационной логики**. Он выполняется **непрерывно** ("continuous assignment statement"), и ему не требуется список чувствительности. Оператор `assign` может использоваться для моделирования таких схем, как трехстабильный буфер (с использованием условного оператора `? :`) или простой буфер. Условные операторы могут быть вложенными для создания мультиплексоров, декодеров и кодировщиков.
- **Task and Function (Задачи и Функции)**: Verilog предоставляет конструкции `task` и `function` для повторно используемого кода. Синтаксис у них схожий.
    - **Ключевые отличия**:
        - Задачи (`task`) могут содержать **задержки**, тогда как функции (`function`) **не могут**. Это означает, что функции пригодны для моделирования только комбинационной логики.
        - Функции (`function`) могут **возвращать значение**, тогда как задачи (`task`) **не могут**.

В разделе также упоминается, что Verilog предоставляет способы моделирования двух типов цифровых элементов: **комбинационных** и **последовательных**. Комбинационные элементы могут быть смоделированы с использованием операторов `assign` и `always`, а последовательные элементы - **только** с использованием оператора `always`. Третий тип блока, `initial`, используется **исключительно в тестбенчах**.

## Verilog In One Day Part-IV (Test Benches)

- **Назначение:** Тестбенчи используются для **тестирования** написанного Verilog кода, чтобы убедиться, что он работает в соответствии со спецификациями проекта. Процесс тестирования аналогичен тому, который используется в университетских цифровых лабораториях: подача входных сигналов и проверка соответствия выходных сигналов ожидаемым значениям.
- **Структура тестбенча:** В тестбенче входы тестируемого модуля обычно объявляются как тип данных `reg`, а выходы — как тип данных `wire`. Это потому, что тестбенч должен управлять (драйвить) входными сигналами и отслеживать (мониторить) выходные.
- **Блок `initial`:** Для инициализации всех входных сигналов в известное состояние в начале симуляции (когда время = 0) используется блок `initial`. Несколько блоков `initial` выполняются в начале симуляции.
- **Блок `always` для тактового сигнала:** Тактовый сигнал (clock) часто генерируется с использованием блока `always`. Пример показывает блок `always`, который переключает значение `clock` с задержкой (#5 единиц времени).
- **Системные задачи (`$finish`, `$monitor`):**
    - Системная задача **`$finish`** используется для завершения симуляции.
    - Системная задача **`$monitor`** используется для **мониторинга изменений** в списке сигналов и вывода их значений в указанном формате.
- **Инициализация тестируемого модуля:** Тестбенч включает экземпляр тестируемого модуля (в примере это модуль `arbiter`, названный `U0`), где порты модуля соединяются с сигналами тестбенча по имени (`.имя_порта (имя_сигнала)`).
- **Пример:** В качестве примера рассматривается тестбенч для двухвходового арбитра, описанного ранее. В `initial` блоке показана последовательность изменения входных сигналов `reset`, `req0`, `req1` для тестирования логики арбитра.

## History Of Verilog


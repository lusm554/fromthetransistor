https://www.asic-world.com/verilog/

1. [[#Introduction]]
2. [[#Verilog In One Day Part-I (modules, data types, operators)]]
3. [[#Verilog In One Day Part-II (Control Statements, Variable Assignment)]]
4. [[#Verilog In One Day Part-III (always blocks, assign statement, task and function)]]
5. [[#Verilog In One Day Part-IV (Test Benches)]]
6. [[#History Of Verilog]]
7. [[#Design And Tool Flow]]
8. 

## Introduction

Verilog — это **Язык Описания Аппаратных Средств (HDL)**. Язык описания аппаратных средств используется для описания цифровой системы, такой как сетевой коммутатор, микропроцессор, память или простой триггер. Это означает, что с помощью HDL можно описать любое цифровое аппаратное обеспечение на любом уровне.

Verilog поддерживает проектирование на многих различных уровнях абстракции. Три из них являются очень важными: **Поведенческий уровень (Behavioral level)**, **Уровень Регистровых Передач (Register-Transfer Level - RTL)** и **Вентильный уровень (Gate Level)**.

- На **Поведенческом уровне** система описывается с помощью параллельных алгоритмов. Каждый алгоритм сам по себе является последовательным и состоит из набора инструкций, выполняемых одна за другой. Основными элементами являются функции (Functions), задачи (Tasks) и блоки `always`. На этом уровне нет учета структурной реализации проекта.
- На **Уровне Регистровых Передач (RTL)** характеристики схемы определяются операциями и передачей данных между регистрами. Используется явный тактовый сигнал. RTL проектирование содержит точные временные границы: операции планируются к выполнению в определенное время. Современное определение RTL кода — "любой синтезируемый код называется RTL кодом".
- На **Вентильном уровне (Gate Level)** характеристики системы описываются логическими связями и их временными свойствами. Все сигналы являются дискретными и могут принимать только определенные логические значения (`0`, `1`, `X`, `Z`). Используемые операции — предопределенные логические примитивы (вентили AND, OR, NOT и т.д.). Использование вентильного моделирования может быть не лучшей идеей для любого уровня логического проектирования; код на вентильном уровне обычно генерируется инструментами синтеза и используется для симуляции на вентильном уровне и для бэкенда.

Verilog, как и любой другой язык описания аппаратных средств, допускает проектирование как по методологии **снизу-вверх (Bottom-up)**, так и **сверху-вниз (Top-down)**. Традиционный метод снизу-вверх, выполняемый на уровне вентилей, становится почти невозможным при возрастающей сложности новых проектов. Желаемым стилем проектирования является метод сверху-вниз, который обеспечивает раннее тестирование, легкую смену технологий и структурированное проектирование. Из-за трудностей полного следования чистому методу сверху-вниз, большинство проектов представляют собой смешение обоих подходов.

## Verilog In One Day Part-I (modules, data types, operators)

Жизнь до появления Verilog была наполнена схемами (schematics). Каждое проектирование, независимо от сложности, выполнялось с помощью схем. Их было сложно верифицировать и они были склонны к ошибкам, что приводило к долгим, утомительным циклам разработки, верификации и повторения.

С приходом Verilog появился **новый способ мышления** о логических схемах. Цикл проектирования с использованием Verilog **более похож на традиционный цикл программирования**. Типичный цикл проектирования в Verilog включает следующие этапы:

- **Спецификации (specs)**: Определение ограничений и требований к проекту, а также того, что именно мы пытаемся построить.
- Высокоуровневое проектирование (High level design).
- Низкоуровневое (микро) проектирование (Low level (micro) design).
- **RTL-кодирование (RTL coding)**: Написание кода Verilog на уровне регистровых передач.
- **Верификация (Verification)**: Проверка правильности работы проекта.
- **Синтез (Synthesis)**: Преобразование кода Verilog в физическую реализацию схемы (например, набор вентилей).

Традиционные методы проектирования с использованием конечных автоматов, таблиц истинности, карт Карно и получения оптимизированных схем хорошо работают для небольших проектов, но становятся сложными и подверженными ошибкам для больших дизайнов. Verilog предлагает альтернативный подход.

В Verilog концепция "черных ящиков" или блоков, имеющих входы, выходы и внутреннюю логику, называется **"модулем" (module)**. Это зарезервированное слово в языке. Модули являются аналогами функций с возвращаемыми значениями в других языках программирования.

В модуле определяются **порты (ports)**, которые могут быть **входными (input)**, **выходными (output)** или **двунаправленными (inout)**. Двунаправленные порты используются для сигналов, которые могут передавать данные в обоих направлениях. Можно также определять **векторные сигналы** (состоящие из более чем одного бита), указывая диапазон бит, например, `[7:0]` для 8-битного сигнала. При этом важно выбрать и последовательно использовать соглашение о порядке бит (endianness).

В Verilog существуют фундаментальные **типы данных**, связанные с аппаратной природой проектирования. Есть два основных типа "драйверов" (объектов, способных управлять нагрузкой):

- Драйвер, который **может хранить значение** (например, триггер). В Verilog этот тип называется **`reg`** (сокращение от register). Тип `reg` используется для хранения значений.
- Драйвер, который **не может хранить значение**, а лишь соединяет две точки (например, провод). В Verilog этот тип называется **`wire`** (для "провода"). Тип `wire` используется для соединения двух точек.

Раздел также обсуждает **операторы (operators)** в Verilog. Операторы во многом **схожи с операторами в языке программирования C**, выполняя арифметические, логические, реляционные операции, операции сравнения, редукции, сдвига, конкатенации и условные операции.

## Verilog In One Day Part-II (Control Statements, Variable Assignment)

1. **Операторы управления**: Verilog включает операторы управления, которые **выглядят так же, как в языке C** (например, `if`, `else`, `repeat`, `while`, `for`, `case`). Однако, поскольку Verilog является Языком Описания Аппаратных Средств (HDL), эти операторы должны транслироваться в аппаратное обеспечение. Поэтому необходимо быть осторожным при их использовании, чтобы дизайн был реализуем в "железе".
2. **`if-else`**: Используется для проверки условия и условного выполнения блока кода. Можно использовать любые операторы для проверки условия, как в C. Допускается вложенность `if-else`. **Важное замечание**: при моделировании комбинационной логики, если не покрыты все случаи (нет блока `else`), это может привести к синтезу **защелки (Latch)**.
3. **`case`**: Используется, когда одна переменная должна быть проверена на соответствие нескольким значениям, подобно оператору `switch` в C++. Начинается с `case`, заканчивается `endcase`. Случаи указываются со знаком двоеточия. **Настоятельно рекомендуется включать `default` случай**, чтобы предотвратить "зависание" конечного автомата (FSM), если входное значение не соответствует ни одному из описанных случаев. Как и в `if-else`, отсутствие покрытия всех случаев (включая `default`) при моделировании комбинационной логики приведет к синтезу **защелки**.
4. **`while`**: Повторно выполняет код до тех пор, пока условие истинно. Обычно используется **не для моделирования аппаратного обеспечения**, а в **тестбенчах** (test benches). Блоки `while`, как и другие блоки операторов, заключаются в `begin` и `end`.
5. **`always` блок**: Вводится как ключевая особенность Verilog. В отличие от большинства языков программирования, которые выполняются **последовательно**, Verilog допускает **параллельное выполнение** множества блоков кода. Блоки `always` выполняются **одновременно**, когда срабатывает одно или несколько условий, указанных в списке чувствительности после символа `@`. Примером условия может быть **положительный фронт тактового сигнала** (`posedge clk`) или сброса (`posedge rst`). Может быть несколько блоков `always` в одной программе, выполняющихся параллельно.
6. **`disable`**: Зарезервированное слово, используемое для отключения блока кода.
7. **`for` цикл**: Почти идентичен циклам `for` в C/C++. **Единственное отличие** в том, что операторы `++` и `--` не поддерживаются; вместо `i++` нужно писать `i = i + 1`. При использовании `for` циклов для RTL нужно убедиться, что код реализуем в аппаратном обеспечении и что цикл не является бесконечным.
8. **`repeat`**: Сходен с `for` циклом, но указывает фиксированное число повторений. Переменные не инкрементируются автоматически, если это не указано явно. Относительно редко используется для фактической реализации аппаратного обеспечения.
9. **Моделирование элементов**: Verilog предоставляет способы моделирования двух типов цифровых элементов: **комбинационных** и **последовательных**.
    - Комбинационные элементы могут быть смоделированы с использованием операторов `assign` и `always`.
    - Последовательные элементы могут быть смоделированы **только** с использованием оператора `always`.
10. **`initial` блок**: Третий тип блока, используемый **исключительно в тестбенчах**. Выполняется только **один раз** в самом начале симуляции (в момент времени 0). Если есть несколько `initial` блоков, все они выполняются одновременно в начале симуляции. Используется для инициализации переменных в тестбенчах.

## Verilog In One Day Part-III (always blocks, assign statement, task and function)

- **Always Blocks (Блоки `always`)**: В отличие от блоков `initial`, которые выполняются только один раз в начале симуляции, блоки `always` выполняются **всегда**. Блок `always` должен иметь либо **список чувствительности (sensitive list)**, либо **задержку**. Список чувствительности указывает, когда именно должен выполниться код внутри блока. Символ `@` после зарезервированного слова `always` указывает, что блок будет запущен при выполнении условия в скобках.
    - **Важное ограничение**: Блок `always` **не может управлять типом данных `wire`**, он может управлять только типами данных `reg` и `integer`.
    - Для моделирования комбинационной логики список чувствительности должен включать все входные переменные (или переменные, управляющие выходом), изменение которых должно вызывать выполнение блока. Существуют два типа списков чувствительности: **уровнево-чувствительные (level sensitive)** для комбинационных схем и **чувствительные к фронту (edge sensitive)** для триггеров. Примером чувствительности к фронту является `@ (posedge clk)`, что означает выполнение при положительном фронте тактового сигнала.
    - В блоках `always` используются два оператора присваивания: **блокирующее присваивание (`=`)** и **неблокирующее присваивание (`<=`)**. Блокирующее присваивание выполняет код **последовательно** внутри блока `begin`/`end`, тогда как неблокирующее присваивание выполняется **параллельно**. Для моделирования последовательных элементов (триггеров) в чувствительных к фронту блоках `always` необходимо использовать **неблокирующее присваивание (`<=`)**.
    - Блок `always` может существовать без списка чувствительности, но в этом случае он должен содержать **задержку** (например, `#5`). Такие блоки часто используются для генерации сигналов, например, тактового, в тестбенчах.
- **Assign Statement (Оператор `assign`)**: Оператор `assign` используется **только для моделирования комбинационной логики**. Он выполняется **непрерывно** ("continuous assignment statement"), и ему не требуется список чувствительности. Оператор `assign` может использоваться для моделирования таких схем, как трехстабильный буфер (с использованием условного оператора `? :`) или простой буфер. Условные операторы могут быть вложенными для создания мультиплексоров, декодеров и кодировщиков.
- **Task and Function (Задачи и Функции)**: Verilog предоставляет конструкции `task` и `function` для повторно используемого кода. Синтаксис у них схожий.
    - **Ключевые отличия**:
        - Задачи (`task`) могут содержать **задержки**, тогда как функции (`function`) **не могут**. Это означает, что функции пригодны для моделирования только комбинационной логики.
        - Функции (`function`) могут **возвращать значение**, тогда как задачи (`task`) **не могут**.

В разделе также упоминается, что Verilog предоставляет способы моделирования двух типов цифровых элементов: **комбинационных** и **последовательных**. Комбинационные элементы могут быть смоделированы с использованием операторов `assign` и `always`, а последовательные элементы - **только** с использованием оператора `always`. Третий тип блока, `initial`, используется **исключительно в тестбенчах**.

## Verilog In One Day Part-IV (Test Benches)

- **Назначение:** Тестбенчи используются для **тестирования** написанного Verilog кода, чтобы убедиться, что он работает в соответствии со спецификациями проекта. Процесс тестирования аналогичен тому, который используется в университетских цифровых лабораториях: подача входных сигналов и проверка соответствия выходных сигналов ожидаемым значениям.
- **Структура тестбенча:** В тестбенче входы тестируемого модуля обычно объявляются как тип данных `reg`, а выходы — как тип данных `wire`. Это потому, что тестбенч должен управлять (драйвить) входными сигналами и отслеживать (мониторить) выходные.
- **Блок `initial`:** Для инициализации всех входных сигналов в известное состояние в начале симуляции (когда время = 0) используется блок `initial`. Несколько блоков `initial` выполняются в начале симуляции.
- **Блок `always` для тактового сигнала:** Тактовый сигнал (clock) часто генерируется с использованием блока `always`. Пример показывает блок `always`, который переключает значение `clock` с задержкой (#5 единиц времени).
- **Системные задачи (`$finish`, `$monitor`):**
    - Системная задача **`$finish`** используется для завершения симуляции.
    - Системная задача **`$monitor`** используется для **мониторинга изменений** в списке сигналов и вывода их значений в указанном формате.
- **Инициализация тестируемого модуля:** Тестбенч включает экземпляр тестируемого модуля (в примере это модуль `arbiter`, названный `U0`), где порты модуля соединяются с сигналами тестбенча по имени (`.имя_порта (имя_сигнала)`).
- **Пример:** В качестве примера рассматривается тестбенч для двухвходового арбитра, описанного ранее. В `initial` блоке показана последовательность изменения входных сигналов `reset`, `req0`, `req1` для тестирования логики арбитра.

## History Of Verilog

- **Начало разработки (около 1984 года)**: Verilog был изначально разработан как проприетарный язык моделирования аппаратного обеспечения компанией Gateway Design Automation Inc.. Считается, что язык был создан на основе функций HiLo (самого популярного на тот момент языка HDL) и традиционных компьютерных языков, таких как C. До 1990 года Verilog не был стандартизирован и постоянно модифицировался в каждой новой версии.
- **Первое использование и Verilog-XL (1985-1987)**: Симулятор Verilog впервые использовался в 1985 году и был значительно расширен до 1987 года. Крупное расширение, Verilog-XL, добавило новые функции и внедрило очень эффективный "XL алгоритм" для моделирования на уровне вентилей.
- **Приобретение Cadence и открытие языка (конец 1990 - 1991)**: В конце 1990 года Cadence Design System приобрела Gateway Automation System, став владельцем языка Verilog. Cadence осознала, что если Verilog останется закрытым языком, индустрия переключится на VHDL. В результате, в 1990 году Cadence организовала Open Verilog International (OVI) и в 1991 году передала OVI документацию по языку Verilog Hardware Description Language, что "открыло" язык.
- **Роль OVI и стандартизация IEEE (1991 - 1995)**: OVI значительно поработала над улучшением Руководства по языку (LRM), сделав спецификацию языка максимально независимой от поставщиков. Вскоре стало понятно, что слишком много компаний, меняющих язык в своих интересах, подорвет цель его публикации в открытом доступе. В связи с этим в середине 1993 года OVI обратилась в IEEE с просьбой сформировать рабочий комитет для стандартизации Verilog. Рабочая группа IEEE 1364 была сформирована в 1994 году для превращения LRM OVI в стандарт IEEE. Эти усилия завершились успешным голосованием в мае 1995 года, и **Verilog стал стандартом IEEE (IEEE Std. 1364-1995) в декабре 1995 года**.
- **Развитие симуляторов**: После того как Cadence открыла Verilog, несколько компаний начали разрабатывать симуляторы Verilog. К 1993 году на рынке появилось несколько таких симуляторов, помимо Cadence, наиболее успешным из которых был VCS (Verilog Compiled Simulator) от Chronologic Simulation, который представлял собой настоящий компилятор в отличие от интерпретатора Verilog-XL.
- **Verilog 2001**: Спустя много лет в Verilog были добавлены новые функции, и новая версия, получившая название Verilog 2001 (также известная как 1364-2001), исправила многие проблемы, присущие версии 1995 года.

## Design And Tool Flow 

![[design_flow.gif]]
Типичный процесс проектирования ASIC/FPGA включает следующие этапы:

- **Спецификация (Specification)**: На этом начальном этапе определяются ключевые параметры системы или дизайна. Примером может быть определение 4-битного счетчика с синхронным сбросом и активным высоким разрешением. Для этого этапа можно использовать текстовые процессоры, такие как Word, Kwriter, AbiWord или Open Office.
- **Высокоуровневое проектирование (High Level Design)**: Здесь определяются различные блоки в разрабатываемой системе и их взаимодействие. Например, при проектировании микропроцессора это подразумевает разделение дизайна на функциональные блоки, такие как регистры, АЛУ, декодер инструкций, интерфейс памяти и т.д.. Для этого этапа также подходят текстовые процессоры, а для создания диаграмм временных задержек (waveform) можно использовать такие инструменты, как waveformer или testbencher.
- **Микропроектирование / Низкоуровневое проектирование (Micro Design/Low level design)**: На этом этапе детально описывается, как будет реализован каждый блок, включая подробности о конечных автоматах, счетчиках, мультиплексорах, дешифраторах и внутренних регистрах. Крайне рекомендуется рисовать временные диаграммы для различных интерфейсов. Этот этап обычно занимает много времени. Инструменты аналогичны высокоуровневому проектированию – текстовые процессоры и программы для временных диаграмм.
- **RTL-кодирование (RTL Coding)**: На этом этапе микродизайн преобразуется в код на языке Verilog или VHDL, используя синтезируемые конструкции языка. Перед верификацией или синтезом обычно производится "линтование" (проверка стиля и потенциальных ошибок) кода. Для кодирования можно использовать текстовые редакторы, такие как Vim, Emacs, conTEXT, или специализированные инструменты вроде HDL TurboWriter.
- **Моделирование (Simulation)**: Это процесс проверки функциональных характеристик моделей на любом уровне абстракции. Цель – убедиться, что RTL-код соответствует функциональным требованиям спецификации. Для этого пишется тестовый стенд (testbench), который генерирует тактовый сигнал (clk), сброс (reset) и необходимые тестовые векторы. Результаты моделирования обычно просматриваются с помощью встроенных в симуляторы просмотрщиков временных диаграмм.
    - Различают **функциональное моделирование** и **временное моделирование (timing simulation)**, также известное как **SDF-моделирование (SDF simulation)** или **моделирование на уровне вентилей (gate level simulation)**. Последнее выполняется после синтеза или трассировки, и включает задержки вентилей и проводов для проверки работы DUT (Device Under Test) на заданной тактовой частоте. На проектирование и верификацию может уходить 60-70% времени. Среди симуляторов упоминаются Modelsim, VCS, Verilog-XL, Veriwell, Finsim, Icarus.
- **Синтез (Synthesis)**: На этом этапе инструменты синтеза, такие как Design Compiler или Synplify, преобразуют RTL-код (на Verilog или VHDL) в примитивы целевой технологии, основываясь на входных ограничениях. Инструмент синтеза также выполняет минимальный анализ временных задержек, чтобы убедиться, что спроектированная схема соответствует требованиям по времени. Важно отметить, что инструменты синтеза не учитывают задержки проводов, только задержки вентилей.
    - После синтеза обычно выполняются **формальная верификация (Formal Verification)** для проверки правильности сопоставления RTL-кода с вентилями, а также **вставка сканирующей цепи (Scan insertion)** в случае ASIC.
- **Размещение и трассировка (Place & Route - P&R)**: На этом этапе полученный после синтеза нетлист на уровне вентилей импортируется в инструмент Place & Route. Все вентили и триггеры размещаются, синтезируется тактовое дерево, маршрутизируется сброс, а затем трассируется каждый блок. Результатом работы P&R инструмента является GDS-файл, который используется литейным цехом для изготовления ASIC. Для FPGA используются инструменты P&R от производителей FPGA. Для ASIC требуются дорогие инструменты P&R, такие как Apollo, но студенты могут использовать LASI, Magic.
- **Пост-кремниевая валидация (Post Si Validation)**: После изготовления чипа (кремния) его необходимо протестировать в реальной среде перед выпуском на рынок. Поскольку скорость моделирования с RTL очень низка, всегда есть вероятность обнаружения ошибок на этапе пост-кремниевой валидации. Этот этап включает проектирование платы и разработку драйверов устройств.


https://www.asic-world.com/verilog/

1. [[#Introduction]]
2. [[#Verilog In One Day Part-I (modules, data types, operators)]]
3. [[#Verilog In One Day Part-II (Control Statements, Variable Assignment)]]
4. [[#Verilog In One Day Part-III (always blocks, assign statement, task and function)]]
5. [[#Verilog In One Day Part-IV (Test Benches)]]
6. [[#History Of Verilog]]
7. [[#Design And Tool Flow]]
8. [[#My first program in Verilog]]
9. [[#Verilog HDL Syntax And Semantics Part-I]]
10. [[#Verilog HDL Syntax And Semantics Part-II]]
11. [[#Verilog HDL Syntax And Semantics Part-III]]
12. [[#Gate Level Modeling Part-I]]
13. [[#Gate Level Modeling Part-II]]
14. 

## Introduction

Verilog — это **Язык Описания Аппаратных Средств (HDL)**. Язык описания аппаратных средств используется для описания цифровой системы, такой как сетевой коммутатор, микропроцессор, память или простой триггер. Это означает, что с помощью HDL можно описать любое цифровое аппаратное обеспечение на любом уровне.

Verilog поддерживает проектирование на многих различных уровнях абстракции. Три из них являются очень важными: **Поведенческий уровень (Behavioral level)**, **Уровень Регистровых Передач (Register-Transfer Level - RTL)** и **Вентильный уровень (Gate Level)**.

- На **Поведенческом уровне** система описывается с помощью параллельных алгоритмов. Каждый алгоритм сам по себе является последовательным и состоит из набора инструкций, выполняемых одна за другой. Основными элементами являются функции (Functions), задачи (Tasks) и блоки `always`. На этом уровне нет учета структурной реализации проекта.
- На **Уровне Регистровых Передач (RTL)** характеристики схемы определяются операциями и передачей данных между регистрами. Используется явный тактовый сигнал. RTL проектирование содержит точные временные границы: операции планируются к выполнению в определенное время. Современное определение RTL кода — "любой синтезируемый код называется RTL кодом".
- На **Вентильном уровне (Gate Level)** характеристики системы описываются логическими связями и их временными свойствами. Все сигналы являются дискретными и могут принимать только определенные логические значения (`0`, `1`, `X`, `Z`). Используемые операции — предопределенные логические примитивы (вентили AND, OR, NOT и т.д.). Использование вентильного моделирования может быть не лучшей идеей для любого уровня логического проектирования; код на вентильном уровне обычно генерируется инструментами синтеза и используется для симуляции на вентильном уровне и для бэкенда.

Verilog, как и любой другой язык описания аппаратных средств, допускает проектирование как по методологии **снизу-вверх (Bottom-up)**, так и **сверху-вниз (Top-down)**. Традиционный метод снизу-вверх, выполняемый на уровне вентилей, становится почти невозможным при возрастающей сложности новых проектов. Желаемым стилем проектирования является метод сверху-вниз, который обеспечивает раннее тестирование, легкую смену технологий и структурированное проектирование. Из-за трудностей полного следования чистому методу сверху-вниз, большинство проектов представляют собой смешение обоих подходов.

## Verilog In One Day Part-I (modules, data types, operators)

Жизнь до появления Verilog была наполнена схемами (schematics). Каждое проектирование, независимо от сложности, выполнялось с помощью схем. Их было сложно верифицировать и они были склонны к ошибкам, что приводило к долгим, утомительным циклам разработки, верификации и повторения.

С приходом Verilog появился **новый способ мышления** о логических схемах. Цикл проектирования с использованием Verilog **более похож на традиционный цикл программирования**. Типичный цикл проектирования в Verilog включает следующие этапы:

- **Спецификации (specs)**: Определение ограничений и требований к проекту, а также того, что именно мы пытаемся построить.
- Высокоуровневое проектирование (High level design).
- Низкоуровневое (микро) проектирование (Low level (micro) design).
- **RTL-кодирование (RTL coding)**: Написание кода Verilog на уровне регистровых передач.
- **Верификация (Verification)**: Проверка правильности работы проекта.
- **Синтез (Synthesis)**: Преобразование кода Verilog в физическую реализацию схемы (например, набор вентилей).

Традиционные методы проектирования с использованием конечных автоматов, таблиц истинности, карт Карно и получения оптимизированных схем хорошо работают для небольших проектов, но становятся сложными и подверженными ошибкам для больших дизайнов. Verilog предлагает альтернативный подход.

В Verilog концепция "черных ящиков" или блоков, имеющих входы, выходы и внутреннюю логику, называется **"модулем" (module)**. Это зарезервированное слово в языке. Модули являются аналогами функций с возвращаемыми значениями в других языках программирования.

В модуле определяются **порты (ports)**, которые могут быть **входными (input)**, **выходными (output)** или **двунаправленными (inout)**. Двунаправленные порты используются для сигналов, которые могут передавать данные в обоих направлениях. Можно также определять **векторные сигналы** (состоящие из более чем одного бита), указывая диапазон бит, например, `[7:0]` для 8-битного сигнала. При этом важно выбрать и последовательно использовать соглашение о порядке бит (endianness).

В Verilog существуют фундаментальные **типы данных**, связанные с аппаратной природой проектирования. Есть два основных типа "драйверов" (объектов, способных управлять нагрузкой):

- Драйвер, который **может хранить значение** (например, триггер). В Verilog этот тип называется **`reg`** (сокращение от register). Тип `reg` используется для хранения значений.
- Драйвер, который **не может хранить значение**, а лишь соединяет две точки (например, провод). В Verilog этот тип называется **`wire`** (для "провода"). Тип `wire` используется для соединения двух точек.

Раздел также обсуждает **операторы (operators)** в Verilog. Операторы во многом **схожи с операторами в языке программирования C**, выполняя арифметические, логические, реляционные операции, операции сравнения, редукции, сдвига, конкатенации и условные операции.

## Verilog In One Day Part-II (Control Statements, Variable Assignment)

1. **Операторы управления**: Verilog включает операторы управления, которые **выглядят так же, как в языке C** (например, `if`, `else`, `repeat`, `while`, `for`, `case`). Однако, поскольку Verilog является Языком Описания Аппаратных Средств (HDL), эти операторы должны транслироваться в аппаратное обеспечение. Поэтому необходимо быть осторожным при их использовании, чтобы дизайн был реализуем в "железе".
2. **`if-else`**: Используется для проверки условия и условного выполнения блока кода. Можно использовать любые операторы для проверки условия, как в C. Допускается вложенность `if-else`. **Важное замечание**: при моделировании комбинационной логики, если не покрыты все случаи (нет блока `else`), это может привести к синтезу **защелки (Latch)**.
3. **`case`**: Используется, когда одна переменная должна быть проверена на соответствие нескольким значениям, подобно оператору `switch` в C++. Начинается с `case`, заканчивается `endcase`. Случаи указываются со знаком двоеточия. **Настоятельно рекомендуется включать `default` случай**, чтобы предотвратить "зависание" конечного автомата (FSM), если входное значение не соответствует ни одному из описанных случаев. Как и в `if-else`, отсутствие покрытия всех случаев (включая `default`) при моделировании комбинационной логики приведет к синтезу **защелки**.
4. **`while`**: Повторно выполняет код до тех пор, пока условие истинно. Обычно используется **не для моделирования аппаратного обеспечения**, а в **тестбенчах** (test benches). Блоки `while`, как и другие блоки операторов, заключаются в `begin` и `end`.
5. **`always` блок**: Вводится как ключевая особенность Verilog. В отличие от большинства языков программирования, которые выполняются **последовательно**, Verilog допускает **параллельное выполнение** множества блоков кода. Блоки `always` выполняются **одновременно**, когда срабатывает одно или несколько условий, указанных в списке чувствительности после символа `@`. Примером условия может быть **положительный фронт тактового сигнала** (`posedge clk`) или сброса (`posedge rst`). Может быть несколько блоков `always` в одной программе, выполняющихся параллельно.
6. **`disable`**: Зарезервированное слово, используемое для отключения блока кода.
7. **`for` цикл**: Почти идентичен циклам `for` в C/C++. **Единственное отличие** в том, что операторы `++` и `--` не поддерживаются; вместо `i++` нужно писать `i = i + 1`. При использовании `for` циклов для RTL нужно убедиться, что код реализуем в аппаратном обеспечении и что цикл не является бесконечным.
8. **`repeat`**: Сходен с `for` циклом, но указывает фиксированное число повторений. Переменные не инкрементируются автоматически, если это не указано явно. Относительно редко используется для фактической реализации аппаратного обеспечения.
9. **Моделирование элементов**: Verilog предоставляет способы моделирования двух типов цифровых элементов: **комбинационных** и **последовательных**.
    - Комбинационные элементы могут быть смоделированы с использованием операторов `assign` и `always`.
    - Последовательные элементы могут быть смоделированы **только** с использованием оператора `always`.
10. **`initial` блок**: Третий тип блока, используемый **исключительно в тестбенчах**. Выполняется только **один раз** в самом начале симуляции (в момент времени 0). Если есть несколько `initial` блоков, все они выполняются одновременно в начале симуляции. Используется для инициализации переменных в тестбенчах.

## Verilog In One Day Part-III (always blocks, assign statement, task and function)

- **Always Blocks (Блоки `always`)**: В отличие от блоков `initial`, которые выполняются только один раз в начале симуляции, блоки `always` выполняются **всегда**. Блок `always` должен иметь либо **список чувствительности (sensitive list)**, либо **задержку**. Список чувствительности указывает, когда именно должен выполниться код внутри блока. Символ `@` после зарезервированного слова `always` указывает, что блок будет запущен при выполнении условия в скобках.
    - **Важное ограничение**: Блок `always` **не может управлять типом данных `wire`**, он может управлять только типами данных `reg` и `integer`.
    - Для моделирования комбинационной логики список чувствительности должен включать все входные переменные (или переменные, управляющие выходом), изменение которых должно вызывать выполнение блока. Существуют два типа списков чувствительности: **уровнево-чувствительные (level sensitive)** для комбинационных схем и **чувствительные к фронту (edge sensitive)** для триггеров. Примером чувствительности к фронту является `@ (posedge clk)`, что означает выполнение при положительном фронте тактового сигнала.
    - В блоках `always` используются два оператора присваивания: **блокирующее присваивание (`=`)** и **неблокирующее присваивание (`<=`)**. Блокирующее присваивание выполняет код **последовательно** внутри блока `begin`/`end`, тогда как неблокирующее присваивание выполняется **параллельно**. Для моделирования последовательных элементов (триггеров) в чувствительных к фронту блоках `always` необходимо использовать **неблокирующее присваивание (`<=`)**.
    - Блок `always` может существовать без списка чувствительности, но в этом случае он должен содержать **задержку** (например, `#5`). Такие блоки часто используются для генерации сигналов, например, тактового, в тестбенчах.
- **Assign Statement (Оператор `assign`)**: Оператор `assign` используется **только для моделирования комбинационной логики**. Он выполняется **непрерывно** ("continuous assignment statement"), и ему не требуется список чувствительности. Оператор `assign` может использоваться для моделирования таких схем, как трехстабильный буфер (с использованием условного оператора `? :`) или простой буфер. Условные операторы могут быть вложенными для создания мультиплексоров, декодеров и кодировщиков.
- **Task and Function (Задачи и Функции)**: Verilog предоставляет конструкции `task` и `function` для повторно используемого кода. Синтаксис у них схожий.
    - **Ключевые отличия**:
        - Задачи (`task`) могут содержать **задержки**, тогда как функции (`function`) **не могут**. Это означает, что функции пригодны для моделирования только комбинационной логики.
        - Функции (`function`) могут **возвращать значение**, тогда как задачи (`task`) **не могут**.

В разделе также упоминается, что Verilog предоставляет способы моделирования двух типов цифровых элементов: **комбинационных** и **последовательных**. Комбинационные элементы могут быть смоделированы с использованием операторов `assign` и `always`, а последовательные элементы - **только** с использованием оператора `always`. Третий тип блока, `initial`, используется **исключительно в тестбенчах**.

## Verilog In One Day Part-IV (Test Benches)

- **Назначение:** Тестбенчи используются для **тестирования** написанного Verilog кода, чтобы убедиться, что он работает в соответствии со спецификациями проекта. Процесс тестирования аналогичен тому, который используется в университетских цифровых лабораториях: подача входных сигналов и проверка соответствия выходных сигналов ожидаемым значениям.
- **Структура тестбенча:** В тестбенче входы тестируемого модуля обычно объявляются как тип данных `reg`, а выходы — как тип данных `wire`. Это потому, что тестбенч должен управлять (драйвить) входными сигналами и отслеживать (мониторить) выходные.
- **Блок `initial`:** Для инициализации всех входных сигналов в известное состояние в начале симуляции (когда время = 0) используется блок `initial`. Несколько блоков `initial` выполняются в начале симуляции.
- **Блок `always` для тактового сигнала:** Тактовый сигнал (clock) часто генерируется с использованием блока `always`. Пример показывает блок `always`, который переключает значение `clock` с задержкой (#5 единиц времени).
- **Системные задачи (`$finish`, `$monitor`):**
    - Системная задача **`$finish`** используется для завершения симуляции.
    - Системная задача **`$monitor`** используется для **мониторинга изменений** в списке сигналов и вывода их значений в указанном формате.
- **Инициализация тестируемого модуля:** Тестбенч включает экземпляр тестируемого модуля (в примере это модуль `arbiter`, названный `U0`), где порты модуля соединяются с сигналами тестбенча по имени (`.имя_порта (имя_сигнала)`).
- **Пример:** В качестве примера рассматривается тестбенч для двухвходового арбитра, описанного ранее. В `initial` блоке показана последовательность изменения входных сигналов `reset`, `req0`, `req1` для тестирования логики арбитра.

## History Of Verilog

- **Начало разработки (около 1984 года)**: Verilog был изначально разработан как проприетарный язык моделирования аппаратного обеспечения компанией Gateway Design Automation Inc.. Считается, что язык был создан на основе функций HiLo (самого популярного на тот момент языка HDL) и традиционных компьютерных языков, таких как C. До 1990 года Verilog не был стандартизирован и постоянно модифицировался в каждой новой версии.
- **Первое использование и Verilog-XL (1985-1987)**: Симулятор Verilog впервые использовался в 1985 году и был значительно расширен до 1987 года. Крупное расширение, Verilog-XL, добавило новые функции и внедрило очень эффективный "XL алгоритм" для моделирования на уровне вентилей.
- **Приобретение Cadence и открытие языка (конец 1990 - 1991)**: В конце 1990 года Cadence Design System приобрела Gateway Automation System, став владельцем языка Verilog. Cadence осознала, что если Verilog останется закрытым языком, индустрия переключится на VHDL. В результате, в 1990 году Cadence организовала Open Verilog International (OVI) и в 1991 году передала OVI документацию по языку Verilog Hardware Description Language, что "открыло" язык.
- **Роль OVI и стандартизация IEEE (1991 - 1995)**: OVI значительно поработала над улучшением Руководства по языку (LRM), сделав спецификацию языка максимально независимой от поставщиков. Вскоре стало понятно, что слишком много компаний, меняющих язык в своих интересах, подорвет цель его публикации в открытом доступе. В связи с этим в середине 1993 года OVI обратилась в IEEE с просьбой сформировать рабочий комитет для стандартизации Verilog. Рабочая группа IEEE 1364 была сформирована в 1994 году для превращения LRM OVI в стандарт IEEE. Эти усилия завершились успешным голосованием в мае 1995 года, и **Verilog стал стандартом IEEE (IEEE Std. 1364-1995) в декабре 1995 года**.
- **Развитие симуляторов**: После того как Cadence открыла Verilog, несколько компаний начали разрабатывать симуляторы Verilog. К 1993 году на рынке появилось несколько таких симуляторов, помимо Cadence, наиболее успешным из которых был VCS (Verilog Compiled Simulator) от Chronologic Simulation, который представлял собой настоящий компилятор в отличие от интерпретатора Verilog-XL.
- **Verilog 2001**: Спустя много лет в Verilog были добавлены новые функции, и новая версия, получившая название Verilog 2001 (также известная как 1364-2001), исправила многие проблемы, присущие версии 1995 года.

## Design And Tool Flow 

![[design_flow.gif]]
Типичный процесс проектирования ASIC/FPGA включает следующие этапы:

- **Спецификация (Specification)**: На этом начальном этапе определяются ключевые параметры системы или дизайна. Примером может быть определение 4-битного счетчика с синхронным сбросом и активным высоким разрешением. Для этого этапа можно использовать текстовые процессоры, такие как Word, Kwriter, AbiWord или Open Office.
- **Высокоуровневое проектирование (High Level Design)**: Здесь определяются различные блоки в разрабатываемой системе и их взаимодействие. Например, при проектировании микропроцессора это подразумевает разделение дизайна на функциональные блоки, такие как регистры, АЛУ, декодер инструкций, интерфейс памяти и т.д.. Для этого этапа также подходят текстовые процессоры, а для создания диаграмм временных задержек (waveform) можно использовать такие инструменты, как waveformer или testbencher.
- **Микропроектирование / Низкоуровневое проектирование (Micro Design/Low level design)**: На этом этапе детально описывается, как будет реализован каждый блок, включая подробности о конечных автоматах, счетчиках, мультиплексорах, дешифраторах и внутренних регистрах. Крайне рекомендуется рисовать временные диаграммы для различных интерфейсов. Этот этап обычно занимает много времени. Инструменты аналогичны высокоуровневому проектированию – текстовые процессоры и программы для временных диаграмм.
- **RTL-кодирование (RTL Coding)**: На этом этапе микродизайн преобразуется в код на языке Verilog или VHDL, используя синтезируемые конструкции языка. Перед верификацией или синтезом обычно производится "линтование" (проверка стиля и потенциальных ошибок) кода. Для кодирования можно использовать текстовые редакторы, такие как Vim, Emacs, conTEXT, или специализированные инструменты вроде HDL TurboWriter.
- **Моделирование (Simulation)**: Это процесс проверки функциональных характеристик моделей на любом уровне абстракции. Цель – убедиться, что RTL-код соответствует функциональным требованиям спецификации. Для этого пишется тестовый стенд (testbench), который генерирует тактовый сигнал (clk), сброс (reset) и необходимые тестовые векторы. Результаты моделирования обычно просматриваются с помощью встроенных в симуляторы просмотрщиков временных диаграмм.
    - Различают **функциональное моделирование** и **временное моделирование (timing simulation)**, также известное как **SDF-моделирование (SDF simulation)** или **моделирование на уровне вентилей (gate level simulation)**. Последнее выполняется после синтеза или трассировки, и включает задержки вентилей и проводов для проверки работы DUT (Device Under Test) на заданной тактовой частоте. На проектирование и верификацию может уходить 60-70% времени. Среди симуляторов упоминаются Modelsim, VCS, Verilog-XL, Veriwell, Finsim, Icarus.
- **Синтез (Synthesis)**: На этом этапе инструменты синтеза, такие как Design Compiler или Synplify, преобразуют RTL-код (на Verilog или VHDL) в примитивы целевой технологии, основываясь на входных ограничениях. Инструмент синтеза также выполняет минимальный анализ временных задержек, чтобы убедиться, что спроектированная схема соответствует требованиям по времени. Важно отметить, что инструменты синтеза не учитывают задержки проводов, только задержки вентилей.
    - После синтеза обычно выполняются **формальная верификация (Formal Verification)** для проверки правильности сопоставления RTL-кода с вентилями, а также **вставка сканирующей цепи (Scan insertion)** в случае ASIC.
- **Размещение и трассировка (Place & Route - P&R)**: На этом этапе полученный после синтеза нетлист на уровне вентилей импортируется в инструмент Place & Route. Все вентили и триггеры размещаются, синтезируется тактовое дерево, маршрутизируется сброс, а затем трассируется каждый блок. Результатом работы P&R инструмента является GDS-файл, который используется литейным цехом для изготовления ASIC. Для FPGA используются инструменты P&R от производителей FPGA. Для ASIC требуются дорогие инструменты P&R, такие как Apollo, но студенты могут использовать LASI, Magic.
- **Пост-кремниевая валидация (Post Si Validation)**: После изготовления чипа (кремния) его необходимо протестировать в реальной среде перед выпуском на рынок. Поскольку скорость моделирования с RTL очень низка, всегда есть вероятность обнаружения ошибок на этапе пост-кремниевой валидации. Этот этап включает проектирование платы и разработку драйверов устройств.

## My first program in Verilog

- **Концепция "Hello World" в Verilog**: Как и в других языках программирования, изучение Verilog начинается с простейшей программы "Hello World", которая подтверждает базовую работоспособность.
- **Структура модуля Verilog**:
    - Любая программа Verilog начинается с зарезервированного слова `module`, за которым следует имя модуля (например, `hello_world`).
    - `initial` блок **выполняется только один раз** в начале симуляции (при time=0). Он часто используется для инициализации переменных в тестовых стендах.
    - Если внутри блока (например, `initial` или `always`) содержится несколько операторов, они должны быть заключены в `begin` и `end`.
    - Модуль завершается зарезервированным словом `endmodule`.
    - Комментарии в Verilog начинаются с двойного слеша `//`.
- **Пример "Hello World"**: Программа `hello_world.v` использует системную задачу `$display` для вывода сообщения "Hello World by Deepak" и `$finish` для завершения симуляции через 10 временных единиц.
- **Проектирование счетчика**:
    - **Спецификации**: Пример разработанного счетчика – это 4-битный синхронный инкрементирующий счетчик с активным высоким синхронным сбросом и активным высоким сигналом разрешения (enable). Эта спецификация соответствует первому этапу "Specification" в общем потоке проектирования.
    - **RTL-кодирование**: Дизайн счетчика реализуется на Verilog. Блок `always @(posedge clock)` запускается при каждом положительном фронте тактового сигнала. Внутри блока проверяется сигнал сброса (`reset`). Если `reset` активен, счетчик обнуляется. В противном случае, если `enable` активен, счетчик инкрементируется.
        - Здесь используются **неблокирующие присваивания** (`<=`), которые характерны для моделирования последовательной логики (триггеров).
- **Тестовые стенды (Test Benches)**:
    - **Назначение**: Любая цифровая схема, включая счетчик, должна быть протестирована, чтобы убедиться, что она работает в соответствии со спецификациями. Тестовые стенды — это часть этапа "Simulation".
    - **Компоненты**: Тестовый стенд для счетчика включает генератор тактового сигнала (`clock`), управление сбросом (`reset`), управление разрешением (`enable`) и логику мониторинга/проверки.
    - **Инициализация и управление**: В `initial` блоке тестового стенда объявляются входные сигналы DUT (Device Under Test) как `reg` (так как они будут управляться тестовым стендом), а выходные сигналы DUT как `wire` (так как они будут мониториться). Затем эти сигналы инициализируются, и применяются тестовые векторы, управляя `reset` и `enable` в определенной последовательности.
    - **Генерация тактового сигнала**: Тактовый сигнал генерируется в отдельном `always` блоке, который переключает значение `clock` каждые 5 временных единиц.
    - **Системные задачи**: Используются `$display` для вывода начальной строки и `$monitor` для непрерывного отслеживания и вывода изменений в значениях сигналов.
    - **Завершение симуляции**: Системная задача `$finish` используется для завершения симуляции.
- **Результаты симуляции**: Приведены примеры табличного вывода `$monitor` и временных диаграмм (waveform), которые позволяют визуально проверить функциональность счетчика. Эти результаты используются для подтверждения, что DUT функционально корректен.

## Verilog HDL Syntax And Semantics Part-I

**Лексические соглашения (Lexical Conventions)**
- Verilog HDL имеет лексические соглашения, **схожие с языком программирования C**.
- Язык **чувствителен к регистру** (case-sensitive).
- Все **ключевые слова** Verilog пишутся **строчными буквами**.

**Пробелы (White Space)**
- Пробелы могут содержать символы **пробелов, табуляции, новой строки и подачи формы** (form feeds).
- Эти символы **игнорируются**, за исключением случаев, когда они служат для разделения других токенов, или внутри строк, где пробелы и табуляция значимы.
- Хороший стиль кодирования предполагает использование пробелов для улучшения читаемости.

**Комментарии (Comments)**
- Существует **две формы** для добавления комментариев:
    - **Однострочные комментарии** начинаются с `//` и заканчиваются символом возврата каретки.
    - **Многострочные комментарии** начинаются с `/*` и заканчиваются `*/`.

**Чувствительность к регистру (Case Sensitivity)**
- Verilog HDL **чувствителен к регистру**, то есть строчные и заглавные буквы считаются уникальными.
- Все **ключевые слова Verilog** написаны **строчными буквами**.
- Не рекомендуется использовать ключевые слова Verilog в качестве уникальных имен, даже если регистр отличается.

**Идентификаторы (Identifiers)**
- Идентификаторы — это **имена**, используемые для объектов, таких как регистры, функции или модули, чтобы на них можно было ссылаться в других частях описания.
- Они должны **начинаться с буквенного символа или символа подчеркивания** (`a-z A-Z _`).
- Могут содержать буквенные символы, числовые символы, подчеркивание и знак доллара (`a-z A-Z 0-9 _ $`).
- Могут быть длиной **до 1024 символов**.

**Экранированные идентификаторы (Escaped Identifiers)**
- Экранированные идентификаторы начинаются с **обратной косой черты** (`\`).
- Весь идентификатор экранируется обратной косой чертой и **завершается пробелом**.
- Они позволяют использовать **любые печатные символы ASCII** в идентификаторе. Например, `\1dff` или `\q ~`.

**Числа в Verilog (Numbers in Verilog)**
- Константные числа могут быть указаны в **десятичном, шестнадцатеричном, восьмеричном или двоичном формате**.
- Отрицательные числа представлены в **дополнительном коде**.
- Символ `?` является альтернативой `z`.
- Символ подчеркивания `_` допустим в любом месте числа, кроме первой позиции, где он игнорируется.

**Целые числа (Integer Numbers)**
- Могут быть **размерными или безразмерными** (безразмерный размер по умолчанию составляет 32 бита).
- Радикс (система счисления) и шестнадцатеричные цифры (`a-f`) **нечувствительны к регистру**.
- Допустимы пробелы между размером, радиксом и значением.
- Пример синтаксиса: `<size>'<radix><value>`.
- Verilog расширяет `<value>`, заполняя указанный `<size>` справа налево.
    - Если `<size>` меньше `<value>`, то левые биты `<value>` **отсекаются**.
    - Если `<size>` больше `<value>`, то левые биты **заполняются** на основе значения самого левого бита в `<value>` (`0` или `1` заполняются `0`, `Z` заполняются `Z`, `X` заполняются `X`).
    - `X` означает неизвестное значение, `Z` — высокое сопротивление, `1` — логическая единица, `0` — логический ноль.

**Вещественные числа (Real Numbers)**
- Verilog поддерживает **вещественные константы и переменные**.
- При присваивании вещественных чисел целым числам Verilog **округляет их до ближайшего целого**.
- Вещественные числа **не могут содержать `Z` и `X`**.
- Могут быть указаны в **десятичной или научной нотации**.

**Числа со знаком и без знака (Signed and Unsigned Numbers)**
- Verilog поддерживает оба типа чисел, но с ограничениями.
- Любое число без префикса знака минус считается **положительным или беззнаковым**.
- Отрицательные числа указываются путем добавления знака минус перед размером для константного числа, делая их **числами со знаком**.
- Verilog внутренне представляет отрицательные числа в **дополнительном коде**.
- Опциональный спецификатор `signed` может быть добавлен для арифметики со знаком.

## Verilog HDL Syntax And Semantics Part-II

**Модули (Modules)**
- **Модули** являются основными **строительными блоками** в проектах на Verilog.
- Иерархия проекта создается путем **инстанцирования модулей** внутри других, более высокоуровневых модулей. Инстанцирование происходит, когда вы используете один модуль внутри другого.
- Пример модуля `addbit` демонстрирует его структуру: объявление входов/выходов и их типов данных, а также логику внутри.

**Порты (Ports)**
- **Порты** обеспечивают **связь** между модулем и его окружением.
- Все модули, кроме модулей верхнего уровня в иерархии, имеют порты.
- **Декларация портов:**
    - Порты могут быть объявлены как `input` (вход), `output` (выход) или `inout` (двунаправленный).
    - Синтаксис объявления: `input [range_val:range_var] list_of_identifiers;` (аналогично для `output` и `inout`).
    - Рекомендуется объявлять **один идентификатор порта на строку** для лучшей читаемости.
    - Пример объявления портов: `input clk;`, `input [15:0] data_in;`, `output [7:0] count;`, `inout data_bi;`.
    - Verilog 2001 позволяет определять порты и их направления одновременно.
- **Векторные сигналы:** Порты могут быть векторными (состоящими из нескольких бит), например, `inout [7:0] address;`. `[7:0]` означает использование **little-endian** соглашения (бит 0 справа), тогда как `[0:7]` означало бы **big-endian** (бит 0 слева).

**Соединение модулей и правила подключения портов**
1. **По порядку портов (Implicit Connection):**
    - Порядок портов должен точно совпадать с порядком в модуле, который инстанцируется.
    - Этот метод **не рекомендуется** для сложного дизайна, так как он может вызвать проблемы при отладке (например, при добавлении или удалении портов).
    - Пример: `addbit u0 (r1, r2, ci, result, c1);`.
2. **По имени (Explicit Connection):**
    - Имена портов должны совпадать с именами портов в инстанцируемом модуле, но **порядок не имеет значения**.
    - Этот метод считается лучшей практикой кодирования, так как он более надежен и облегчает отладку.
    - Пример: `addbit u0 (.a (r1), .b (r2), .ci (ci), .sum (result), .co (c1));`.

**Правила подключения портов (Port Connection Rules)**
- **Входы (Inputs):** Внутри модуля должны быть типа `net` (например, `wire`). Снаружи могут быть подключены к переменным типа `reg` или `net`.
- **Выходы (Outputs):** Внутри модуля могут быть типа `net` или `reg`. Снаружи должны быть подключены к переменным типа `net`.
- **Двунаправленные (Inouts):** И внутри, и снаружи всегда должны быть типа `net`. Могут быть подключены только к переменным типа `net`.
- **Согласование ширины (Width matching):** Допустимо соединять внутренние и внешние порты разной ширины, но это может вызвать проблемы при синтезе.
- **Неподключенные порты (Unconnected ports):** Разрешены и обозначаются запятой `,` (при подключении по порядку) или пустыми скобками `()` (при подключении по имени).
- Типы данных `net` используются для соединения структур. Тип данных `net` требуется, если сигнал может быть управляем структурным соединением.

Раздел также включает примеры использования модуля `d_ff` (D-триггера) для 
демонстрации неподключенных портов.

## Verilog HDL Syntax And Semantics Part-III

**Иерархические Идентификаторы (Hierarchical Identifiers)**
- **Иерархические пути** используются для доступа к сигналам внутри вложенных модулей.
- Они строятся, начиная с идентификатора верхнего модуля, за которым следуют идентификаторы экземпляров модуля, разделенные точками.
- Это полезно для наблюдения за значениями сигналов внутри модулей более низкого уровня или для принудительной установки значения во внутреннем модуле.
- Пример демонстрирует использование иерархических идентификаторов для мониторинга выходов сумматоров (`u0.sum`, `u1.sum` и т.д.) внутри модуля `adder_hier` из тестового окружения.

**Типы Данных (Data Types)**
В Verilog существуют два основных типа данных:
1. **Сети (Nets)**: Представляют собой **структурные соединения** между компонентами.
2. **Регистры (Registers)**: Представляют переменные, используемые для **хранения данных**.

Каждый сигнал имеет связанный с ним тип данных:
- **Явно объявленный** (Explicitly declared): С помощью объявления в коде Verilog.
- **Неявно объявленный** (Implicitly declared): Если объявление отсутствует, при использовании для соединения структурных блоков в коде. Неявное объявление всегда является сетевым типом `wire` и имеет ширину в один бит.

**Типы Сетей (Types of Nets)**:
- `wire`, `tri`: Взаимосвязывающий провод без специальной функции разрешения.
- `wor`, `trior`: Проводные выходы, объединенные по логическому ИЛИ (моделирует ECL).
- `wand`, `triand`: Проводные выходы, объединенные по логическому И (моделирует открытый коллектор).
- `tri0`, `tri1`: Сеть подтягивается к логическому 0 или 1, когда не управляется.
- `supply0`, `supply1`: Сеть имеет постоянное логическое 0 или логическое 1 (сила питания).
- `trireg`: Сохраняет последнее значение, когда управляется `z` (трехстабильное состояние).
- **Примечание**: Среди всех типов сетей `wire` используется наиболее широко. Примеры демонстрируют поведение `wor`, `wand`, `tri` и `trireg`.

**Типы Регистров (Register Data Types)**:
- Регистры **хранят последнее присвоенное им значение** до тех пор, пока другое оператор присваивания не изменит их значение.
- Они используются как переменные в процедурных блоках, таких как `initial` и `always`.
- Массивы регистров могут быть созданы для моделирования памяти.
- **`reg`**: Переменная без знака.
- **`integer`**: Переменная со знаком, 32 бита.
- **`time`**: Целое число без знака, 64 бита.
- **`real`**: Переменная с плавающей запятой двойной точности.
- **Примечание**: Среди всех типов регистров `reg` используется наиболее широко.

**Строки (Strings)**
- **Строка** — это последовательность символов, заключенная в двойные кавычки и расположенная на одной строке.
- Строки трактуются как последовательность восьмибитных значений ASCII.
- Для хранения строки объявляется регистр достаточного размера, чтобы вместить максимальное количество символов; символ завершения строки не требуется, так как Verilog его не хранит.
- Строки могут быть манипулированы с использованием стандартных операторов.
- Если переменная больше, чем требуется для присваиваемого значения, Verilog дополняет содержимое слева нулями после присваивания.
- В строках могут использоваться специальные символы, которым предшествует **экранирующий символ** (`\`). Примеры включают `\n` (новая строка), `\t` (табуляция), `\\` (обратная косая черта), `\"` (двойные кавычки), `\ddd` (символ, заданный 1-3 восьмеричными цифрами) и `%%` (символ процента).

## Gate Level Modeling Part-I

"Gate Level Modeling Part-I" описывает использование встроенных примитивов Verilog, которые редко применяются при написании RTL-кода, но важны для моделирования ячеек ASIC/FPGA после синтеза и для симуляции на уровне вентилей, известной как SDF-симуляция. Выходной нетлист от инструмента синтеза также представлен в формате примитивов Verilog на уровне вентилей. Инженеры RTL также могут использовать примитивы на уровне вентилей или ячейки библиотеки ASIC при работе с ячейками ввода/вывода (IO CELLS) и кросс-доменными синхронизирующими ячейками.

Источники выделяют следующие типы примитивов:
- **Примитивы вентилей (Gate Primitives)**:
    - Это N-входовые логические элементы. Первым терминалом в списке терминалов вентиля всегда является выход, а остальные терминалы являются входами.
    - Примеры включают: `and` (И), `nand` (И-НЕ), `or` (ИЛИ), `nor` (ИЛИ-НЕ), `xor` (ИСКЛЮЧАЮЩЕЕ ИЛИ), `xnor` (ИСКЛЮЧАЮЩЕЕ ИЛИ-НЕ).
- **Примитивы передающих элементов (Transmission Gate Primitives)**:
    - Передающие элементы являются **двунаправленными** и могут быть резистивными или нерезистивными.
    - Синтаксис обычно: `keyword unique_name (inout1, inout2, control);`.
    - Примеры включают: `not` (инвертор N-выходов), `buf` (буфер N-выходов), `bufif0` (трехстабильный буфер, активный низкий вход разрешения), `bufif1` (трехстабильный буфер, активный высокий вход разрешения), `notif0` (трехстабильный инвертор, низкий вход разрешения), `notif1` (трехстабильный инвертор, высокий вход разрешения).
    - Примитивы `tran` и `rtran` (резистивный) всегда включены и не имеют управляющей линии. `tran` может использоваться для соединения двух проводов с раздельными драйверами, а `rtran` может ослаблять сигналы.
- **Примитивы переключателей (Switch Primitives)**:
    - Существует шесть различных примитивов переключателей (моделей транзисторов): `nmos`, `pmos`, `cmos` и соответствующие три резистивные версии: `rnmos`, `rpmos`, `rcmos`.
    - CMOS-переключатели имеют два затвора и, следовательно, два управляющих сигнала.
    - Синтаксис обычно: `keyword unique_name (drain, source, gate)`.
    - Также включают: `tranif1`, `tranif0`, `rtranif1`, `rtranif0` (двунаправленные транзисторы с управлением), `tran`, `rtran` (двунаправленные проходные транзисторы), `pullup` (подтягивающий резистор), `pulldown` (стягивающий резистор).
    - Все переключатели передают сигналы только от истока к стоку; неправильное подключение может привести к выходам с высоким импедансом. Резистивные устройства снижают силу сигнала на выходе на один уровень.

**Логические значения и силы сигнала (Logic Values and Signal Strengths)**: Verilog HDL использует четыре логических значения:
- **0**: ноль, низкий уровень, ложь.
- **1**: один, высокий уровень, истина.
- **z** или **Z**: высокий импеданс, плавающее состояние.
- **x** или **X**: неизвестное, неинициализированное, состояние конфликта.

**Уровни силы Verilog (Verilog Strength Levels)**: Verilog определяет уровни силы, которые используются для разрешения конфликтов, когда несколько драйверов пытаются управлять одной линией. Чем выше уровень силы, тем сильнее драйвер:
- **7 Supply Drive**: `supply0`, `supply1` (самый сильный).
- **6 Strong Pull**: `strong0`, `strong1`.
- **5 Pull Drive**: `pull0`, `pull1`.
- **4 Large Capacitance**: `large`.
- **3 Weak Drive**: `weak0`, `weak1`.
- **2 Medium Capacitance**: `medium`.
- **1 Small Capacitance**: `small`.
- **0 Hi Impedance**: `highz0`, `highz1` (самый слабый).

Пример: Если два буфера имеют выходы "Pull 1" и "Supply 0" соответственно, то поскольку "supply 0" сильнее, чем "pull 1", итоговое значение на выходе будет определяться "Supply 0". Аналогично, если выходы "Supply 1" и "Large 1", то "Supply 1" сильнее, и выход примет его значение.

## Gate Level Modeling Part-II

ASIC-вендоры используют этот метод для создания Verilog-описаний ASIC-ячеек, используя встроенные примитивы Verilog и пользовательские примитивы (UDP).

- **Реализация И-НЕ (AND) вентиля из ИЛИ-НЕ (NAND) вентилей**:
    - Пример показывает, как структурная модель И-НЕ вентиля может быть создана путем инстанцирования двух NAND-вентилей.
    - В коде `nand U1(W,X, Y);` и `nand U2(F, W, W);` используются для создания этой логики, где `W` является промежуточным сигналом, а `F` — конечным выходом.
    - Предоставляется тестовый код для проверки функциональности этой модели.
- **Реализация D-триггера из ИЛИ-НЕ (NAND) вентилей**:
    - Источники демонстрируют, как D-триггер может быть построен с использованием четырех NAND-вентилей (`U1`, `U2`, `U3`, `U4`), соединяющих входы `D` и `CLK` с выходами `Q` и `Q_BAR`.
    - Каждый NAND-вентиль инстанцируется с определенными соединениями, например, `nand U1 (X,D,CLK);` и `nand U3 (Q,Q_BAR,X);`.
    - Включен тестовый код для проверки поведения D-триггера.
- **Реализация мультиплексора из базовых примитивов (вентилей)**:
    - Мультиплексор создается путем использования инверторов (`not`), И-вентилей (`and`) и ИЛИ-вентилей (`or`).
    - Сначала инвертируются сигналы выбора (`A`, `B`) для создания `a_inv` и `b_inv`.
    - Затем используются 3-входовые И-вентили (`y0`, `y1`, `y2`, `y3`) для комбинации входных данных (`c0`, `c1`, `c2`, `c3`) с инвертированными и неинвертированными сигналами выбора.
    - Наконец, 4-входовый ИЛИ-вентиль (`Y`) объединяет выходы всех И-вентилей для формирования конечного мультиплексированного вывода.
    - К модели прилагается тестовый код для симуляции.


[Перевод книги](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4._%D0%A2%D0%B0%D0%B9%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8)

Prompt:
```text
Выдели суть, основные мысли, самое важное из "Глава 21. Шины". Ответь в формате булетов. Добавь примеры.
```

1. [[#Глава 4. Устройство фонарика]]
2. [[#Глава 5. Заглядывая за угол]]
3. [[#Глава 6. Телеграфы и реле]]
4. [[#Глава 7. Наши десять цифр]]
5. [[#Глава 8 Альтернативы десятке]]
6. [[#Глава 10. Логика и переключатели]]
7. [[#Глава 11. Логические вентили]]
8. [[#Глава 12. Двоичный сумматор]]
9. [[#Глава 13. А как насчет вычитания?]]
10. [[#Глава 14. Обратная связь и триггеры]]
11. [[#Глава 15. Байты и шестнадцатеричные числа]]
12. [[#Глава 16. Сборка памяти]]
13. [[#Глава 17. Автоматизация]]
14. [[#Глава 18. От счетов к микросхемам]]
15. [[#Глава 19. Два классических микропроцессора]]
16. [[#Глава 20. Набор символов ASCII]]
17. [[#Глава 21. Шины]]
18. [[#Глава 22. Операционная система]]
19. [[#Глава 23. Фиксированная точка, плавающая точка]]
20. [[#Глава 24. Языки высокого и низкого уровня]]
21. [[#Глава 25. Графическая революция]]
22. 

## Глава 4. Устройство фонарика

* Вольты - напряжение, как давление воды в трубе. 
* Омы - сопротивление протеканию электричества, зависит от провода или другого проводника.
* Амперы - сила тока, кол-во тока протекающее в единицу времени. Зависит от сопротивления и напряжения.
* Ватт - единица измерения электрической мощности. Эта мощность показывает как быстро электрическая энергия преобразуется в другие виды энергии, например, в свет и тепло в лампочке фонарика. Мощность (ватты) = Напряжение (вольты) × Сила тока (амперы).
* Электричество создается движением электронов. Батарейки благодаря химическим реакциям заставляют электроны двигаться от отрицательной клеммы к положительной клемме.
* Вещества, которые хорошо проводят электричество, называются проводниками (например, медь), а те, которые плохо проводят, — изоляторами (например, резина).

## Глава 5. Заглядывая за угол

* Чем длиннее провода, тем выше их сопротивление, что приводит к уменьшению силы тока и, как следствие, к более тусклому свечению лампочки, используемой для сигнализации.
* Более толстый провод - меньшее сопротивление.
* В главе затрагивается идея экономии проводов за счет использования общей части цепи, которую можно заменить, например, планетой Земля.

## Глава 6. Телеграфы и реле

* Принцип электрического телеграфа прост: манипуляции на одном конце провода вызывают эффект на другом конце.
* Изначально Морзе не мог использовать лампочку в качестве сигнального устройства, так как она была изобретена позже (в 1879 году). Вместо этого он использовал явление электромагнетизма.
* Телеграфный "ключ" был простым переключателем, оптимизированным для быстрой работы. Короткое нажатие соответствовало точке, длинное - тире азбуки Морзе.
* Приемник телеграфа использовал электромагнит, управлявший металлическим рычагом (изначально пером), который выписывал точки и тире на бумажной ленте. Позже перо было заменено клопфером, а телеграфисты научились интерпретировать код на слух по длительности щелчков.
* Первые телеграфные системы столкнулись с проблемой затухания сигнала на больших расстояниях из-за сопротивления проводов. Проблему решили через реле - механизм дублирующий сигнал.

## Глава 7. Наши десять цифр

* Позиционная запись: Ключевой особенностью десятичной системы является позиционная запись, где значение каждой цифры зависит от ее положения в числе. Каждая позиция соответствует степени числа 10. Например, в числе 4825 цифра 4 означает 4 тысячи (4 × 10³), 8 означает 8 сотен (8 × 10²), 2 означает 2 десятка (2 × 10¹), а 5 означает 5 единиц (5 × 10⁰).
* Использование нуля: Для обозначения отсутствия значения в определенной позиции используется цифра 0 в качестве заполнителя. Это позволяет записывать числа, не имея специального символа для каждой степени десяти.
* Представление дробных чисел: Позиционная запись распространяется и на дробные числа с помощью десятичной запятой. Цифры после запятой являются множителями отрицательных степеней числа 10. Например, 42705,684 = 4 × 10⁴ + 2 × 10³ + 7 × 10² + 0 × 10¹ + 5 × 10⁰ + 6 × 10⁻¹ + 8 × 10⁻² + 4 × 10⁻³.
* Удобство арифметических операций: Одним из главных достоинств позиционной системы является простота выполнения арифметических операций, таких как сложение. Сложение многозначных чисел сводится к поэтапному сложению однозначных чисел в каждом разряде.

## Глава 8. Альтернативы десятке

* Основание 10 не является единственным вариантом: Глава подчеркивает, что выбор основания 10 для нашей системы счисления связан с тем, что у большинства людей десять пальцев, что облегчает счет. Однако это не единственный возможный или логически необходимый выбор.
* Восьмеричная система (основание 8): Рассматривается как пример альтернативной системы, которая могла бы быть естественной, если бы у людей было по четыре пальца на руке (как у мультяшек).

	* В восьмеричной системе используются только цифры от 0 до 7 .
	* Число 10 в восьмеричной системе обозначает восемь в десятичной системе. Чтобы избежать путаницы, при работе с другими системами счисления рекомендуется называть числа поразрядно, например, "один-ноль восьмеричное" вместо "десять".
	* Приводятся примеры перевода чисел и сравнения величин в десятичной и восьмеричной системах счисления.
	* Подчеркивается, что арифметические операции (сложение и умножение) могут выполняться в восьмеричной системе по аналогии с десятичной, но с учетом основания 8.
	* Круглые восьмеричные числа (оканчивающиеся нулями) соответствуют степеням двойки в десятичной системе.
* Четверичная система (основание 4): Кратко упоминается как система, которая могла бы подойти омарам (у которых нет пальцев, но есть клешни). Использует цифры 0, 1, 2, 3. 
* Двоичная система (основание 2): Вводится как система, где используется всего две цифры: 0 и 1.
	* Подчеркивается ее простота, где для представления выбора "да" или "нет" достаточно одного бита (двоичной цифры).
	* Приводится пример умножения в двоичной системе.
	* Демонстрируется таблица первых шестнадцати двоичных чисел и их десятичные эквиваленты.
* Позиционная запись универсальна: Главная прелесть позиционной записи заключается в ее применимости к системам счисления с любым основанием, а не только к десятичной . В любой системе счисления значение цифры определяется ее позицией, которая соответствует степени основания системы.

## Глава 9. За битом бит

- **Бит как 0 или 1:** Глава подчеркивает, что бит — это сокращение от "двоичная цифра" (binary digit) и представляет собой одну из двух возможных величин: 0 или 1. Бит является простейшей формой передачи информации, необходимой, например, для ответа "да" или "нет".
- **Кодирование информации битами:** Различные последовательности битов могут использоваться для представления разнообразной информации, и значение кода определяется соглашением. Автор приводит примеры кодирования рейтингов фильмов с помощью 3-битных кодов.
- **Связь количества битов и кодов:** Количество возможных уникальных кодов, которые можно создать с помощью определенного числа битов, равно двум в степени этого числа (2^n, где n — количество битов). Каждый добавленный бит удваивает количество доступных кодов.
- **Применение битов на практике:**
    - **Светочувствительность фотопленки:** Для кодирования 24 стандартных значений светочувствительности пленки требуется 5 битов (так как 2^4 = 16 недостаточно, а 2^5 = 32 достаточно).
    - **Штрихкод UPC:** Универсальный код товара (UPC) представляет собой последовательность из 95 бит, сгруппированных для кодирования информации о товаре, включая левый и правый ограничительные шаблоны, цифры слева и справа от центрального разделителя. Несмотря на то, что для представления десятичной цифры обычно достаточно четырех бит, в штрихкодах используется по семь бит на цифру для повышения надежности и защиты от ошибок.
    - **Азбука Морзе:** Азбука Морзе, состоящая из точек и тире, может быть представлена в виде битов, где, например, точка может соответствовать одному биту, а тире — двум. Паузы между символами и словами также представляются нулевыми битами. При переводе азбуки Морзе в биты получается последовательность, напоминающая штрихкод.
    - **Шрифт Брайля:** Шрифт Брайля является 6-битовым кодом, где каждый символ представлен комбинацией из шести точек, каждая из которых может быть выпуклой или плоской.

## Глава 10. Логика и переключатели

- Глава начинается с утверждения, что **истину и ложь можно обозначить с помощью 1 и 0 соответственно**.
- **Джордж Буль создал булеву алгебру, оперирующую не числами, а классами (множествами)**.
- В булевой алгебре **«+» означает объединение двух классов (логическое ИЛИ)**, а **«×» (или простое написание рядом) означает пересечение двух классов (логическое И)**. Иногда для избежания путаницы используются символы $\cup$ и $\cap$, но Буль предпочитал «+» и «×» в абстрактном смысле.
- **Коммутативные, ассоциативные и дистрибутивные правила обычной алгебры остаются справедливыми в булевой алгебре**. Более того, в булевой алгебре оператор «+» также является дистрибутивным по отношению к оператору «×».
- Булева алгебра может быть использована для представления и решения логических задач, таких как силлогизмы. В главе приводится пример с критериями выбора кошки, где характеристики представлены переменными 0 и 1, а критерии — булевым выражением.
- Глава переходит к **связи булевой алгебры с электрическими переключателями**.
- **Последовательное соединение двух переключателей соответствует логической операции И**, так как лампа загорается только если оба переключателя замкнуты. В булевой алгебре это описывается как $A \times B = C$, где $C=1$ только если $A=1$ и $B=1$.
- **Параллельное соединение двух переключателей соответствует логической операции ИЛИ**, так как лампа загорается если замкнут хотя бы один из переключателей. В булевой алгебре это описывается как $A + B = C$, где $C=1$ если $A=1$ или $B=1$ (или оба равны 1). Важно отметить, что $1 + 1 = 1$ в булевой алгебре.
- Для операций И и ИЛИ приведены **таблицы истинности**, показывающие результаты для всех комбинаций входных значений (0 и 1).
- Используя переключатели и лампочки, можно **физически реализовать логические условия**, описанные булевой алгеброй.
- В конце главы ставится вопрос о возможности использования нескольких переключателей для автоматической проверки соответствия котят заданным критериям, что является предвестием использования булевой алгебры для проектирования компьютерных схем.

## Глава 11. Логические вентили

- **Логические вентили выполняют элементарные логические задачи, блокируя или пропуская электрический ток**. Своё название они получили не от сантехнических вентилей, хотя и напоминают их по принципу действия.
- Логические вентили могут быть построены на основе реле, которые, в отличие от ручных переключателей, могут включаться и выключаться автоматически.
- **Основные логические вентили, рассматриваемые в главе, включают:**
    - **Вентиль И (AND):** Лампочка загорается только если замкнуты _все_ последовательно соединенные переключатели (или активированы все реле). Выход равен 1 только если все входы равны 1.
    - **Вентиль ИЛИ (OR):** Лампочка загорается если замкнут _хотя бы один_ из параллельно соединенных переключателей (или активировано хотя бы одно реле). Выход равен 1 если хотя бы один вход равен 1.
    - **Инвертор (NOT):** Единственное реле, подключенное таким образом, что лампочка горит при разомкнутом переключателе и гаснет при замкнутом. **Инвертирует входной сигнал: 0 становится 1, а 1 становится 0**. Хотя инвертор технически не является логическим вентилем (так как имеет только один вход), он часто используется в логических схемах.
    - **Вентиль ИЛИ-НЕ (NOR):** Поведение прямо противоположно вентилю ИЛИ. Лампочка горит, когда _оба_ переключателя разомкнуты, и гаснет, если замкнут хотя бы один. **Выход равен 1 только если оба входа равны 0**.
    - **Вентиль И-НЕ (NAND):** Лампочка горит, когда _хотя бы один_ из переключателей разомкнут, и гаснет только когда _оба_ переключателя замкнуты. **Выход равен 0 только если оба входа равны 1**.
- Для каждого логического вентиля существует своя условная графическая схема.
- Комбинации логических вентилей могут создавать более сложные логические функции. Например, вентиль И с двумя инвертированными входами эквивалентен вентилю ИЛИ-НЕ. Аналогично, вентиль ИЛИ с двумя инвертированными входами эквивалентен вентилю И-НЕ.

## Глава 12. Двоичный сумматор

- **Двоичный сумматор предназначен для сложения двоичных чисел**.
- Сложение двоичных чисел происходит **по столбцам, начиная справа, с учетом переноса в следующий столбец**.
- Операции сложения и переноса рассматриваются **отдельно**.
- Для построения двоичного сумматора используются **логические вентили**.
- **Полусумматор** складывает два двоичных бита и выдает **бит суммы (с помощью вентиля Исключающее ИЛИ) и бит переноса (с помощью вентиля И)**.
- Полусумматор **не может учитывать входящий бит переноса** от предыдущей операции сложения.
- **Полный сумматор** складывает три двоичных бита: два входных бита и **бит входящего переноса**.
- Полный сумматор может быть построен с использованием **двух полусумматоров и вентиля ИЛИ**.
- Приведены **таблицы истинности для суммы и переноса при сложении двух двоичных цифр**.
- Для сложения многоразрядных двоичных чисел используются **каскадно соединенные полные сумматоры**, где **выход переноса одного полного сумматора соединяется со входом переноса следующего**.
- Рассмотрена схема **8-битного сумматора**, способного складывать два 8-битных числа.
- Введены обозначения для входов (A0-A7, B0-B7), выходов суммы (S0-S7) и сигналов переноса (CI / Carry In - входящий перенос, CO / Carry Out - выходящий перенос) для 8-битного сумматора.
- Объяснено понятие **младшего (LSB / Least Significant Bit) и старшего (MSB / Most Significant Bit) битов**.
- **8-битные сумматоры могут быть объединены в каскад для создания 16-битных (и более) сумматоров**.
- Первые компьютеры использовали **реле** для построения сумматоров, и для 8-битного сумматора требовалось значительное количество реле (около 144).
- Современные компьютеры используют **транзисторы**, которые работают аналогично реле, но являются более быстрыми, компактными и энергоэффективными.
- Упоминаются **более быстрые схемы сумматоров с ускоренным переносом** (carry lookahead), которые работают быстрее, чем сумматоры с последовательным переносом.

## Глава 13. А как насчет вычитания?

- **Сложность традиционного вычитания с заимствованием для аппаратной реализации.** В главе начинается с демонстрации обычного десятичного вычитания (например, 253 - 176), чтобы показать, насколько сложным является процесс "заимствования" для реализации в виде логических схем.
- **Представление метода вычитания без заимствования с использованием дополнения до девяти (в десятичной системе).** Автор предлагает "трюк", позволяющий избежать заимствований при вычитании. Для этого вычитаемое сначала вычитается из числа, состоящего из девяток (999 для трехзначных чисел), чтобы получить дополнение до девяти. Затем это дополнение складывается с уменьшаемым, после чего к результату прибавляется 1 и вычитается соответствующая степень десятки.
    - Пример: Для вычитания 176 из 253: 999 - 176 = 823; 253 + 823 = 1076; 1076 + 1 - 1000 = 77.
- **Переход к двоичному вычитанию и использованию дополнения до единицы.** Аналогичный метод применяется и к двоичным числам, где используется дополнение до единицы. Чтобы получить дополнение до единицы, достаточно инвертировать каждый бит двоичного числа (0 становится 1, а 1 становится 0).
    - Пример: Для вычитания 10110000 из 11111101: Дополнение до единицы числа 10110000 равно 01001111. Затем складываем: 11111101 + 01001111 = 101001100. После чего прибавляем 1: 101001101 и вычитаем 100000000, получая 0001001101 (77 в десятичной системе).
- **Реализация вычитания с помощью сумматора через дополнение до единицы и прибавление 1.** Описывается, как модифицировать схему сумматора для выполнения вычитания. Это достигается за счет инвертирования битов вычитаемого (получения дополнения до единицы) и установки входного переноса (CI) сумматора в 1. Для инвертирования битов используются вентили Исключающее ИЛИ (Искл-ИЛИ).
- **Обработка переполнения и исчезновения (отрицательных результатов) при вычитании.** Рассматривается, как сигналы переноса (CO) от сумматора и сигнал "Вычитание" используются для индикации переполнения или ситуации, когда вычитаемое больше уменьшаемого (что привело бы к отрицательному результату). Отмечается, что разработанная схема не предназначена для отображения отрицательных чисел.
- **Введение понятия представления отрицательных двоичных чисел с использованием "дополнения до двух".** Глава объясняет, что в компьютерах отрицательные числа обычно представляются с помощью метода дополнения до двух, что позволяет выполнять вычитание как сложение отрицательного числа.
    - Для получения дополнения до двух числа, сначала вычисляется его дополнение до единицы, а затем к результату прибавляется 1.
    - Пример: Десятичное число 125 в двоичном формате - 01111101. Его дополнение до двух: инвертируем (10000010) и прибавляем 1 (10000011), что представляет -125.
- **Использование дополнения до двух упрощает выполнение операций сложения и вычитания над знаковыми числами.** При использовании представления чисел в формате дополнения до двух, операции сложения и вычитания могут выполняться с помощью одних и тех же схем сумматора, без необходимости в отдельных механизмах для вычитания.
    - Пример: Сложение -127 (10000001 в дополнении до двух) и 124 (01111100) дает -3 (11111101).

## Глава 14. Обратная связь и триггеры

- **Триггеры как элементы памяти:** Ключевая функция триггеров заключается в обеспечении **памяти для электронных схем**. Они способны запоминать предыдущие состояния и сохранять историю событий. Без памяти схема не смогла бы, например, выполнять последовательные вычисления.    
    - **Пример:** Чтобы сложить два числа, схеме нужно сначала запомнить первое число, а затем прибавить к нему второе. Триггер может хранить первое число.
- **RS-триггер (Reset/Set):** Это **простейший тип триггера**, состоящий из двух логических элементов ИЛИ-НЕ. Он имеет два входа: S (Set - установка) и R (Reset - сброс), а также два выхода: Q и (<span style="text-decoration:overline">Q</span>) (инверсный Q).
    - RS-триггер запоминает, какой из входов (S или R) был активен последним.
    - Существует **запрещенная комбинация входов (S=1 и R=1)**, при которой оба выхода становятся равны 0, нарушая условие, что (\overline{Q}) всегда противоположен Q.
    - **Пример:** Если на вход S подается 1, выход Q становится 1 и сохраняет это значение, даже после того как S возвращается к 0. Если затем на вход R подается 1, Q становится 0 и остается таким после возвращения R к 0.
- **Более полезная схема для запоминания бита:** Рассматривается схема, которая может **запомнить, был ли определенный сигнал (0 или 1) активен в конкретный момент времени**. Вводятся понятия входа "Данные" и управляющего сигнала "Запомнить этот бит". Когда "Запомнить этот бит" равен 1, выход следует за "Данными". Когда "Запомнить этот бит" становится 0, схема запоминает последнее значение "Данных".
- **D-триггер со срабатыванием по уровню (D-защелка):** Эта схема (также называемая D-защелкой) использует вход синхронизации (Clk), который соответствует сигналу "Запомнить этот бит".
    - Когда Clk равен 1, выход Q **следует за входным сигналом D (Данные)**.
    - Когда Clk переходит в 0, выход Q **сохраняет последнее значение D**.
    - D-защелка **"запирает" один бит данных** и удерживает его, представляя собой ячейку памяти емкостью в один бит.
- **Защелки со срабатыванием по фронту:** В отличие от защелок, реагирующих на уровень сигнала Clk, защелки со срабатыванием по фронту **сохраняют данные в краткий момент перехода сигнала Clk из 0 в 1**. Они считаются несколько проще.
- **D-триггер с входом "Очистка" (Clear, Clr):** Добавление входа Clr позволяет **принудительно установить выход Q в 0**, независимо от значений на входах D и Clk. Это используется для сброса (очистки) сохраненной информации в триггере.
- **Применение D-триггера со срабатыванием по фронту в качестве делителя частоты:** Подключение выхода Q D-триггера со срабатыванием по фронту ко входу D и осциллятора к входу Clk создает схему, которая **делит частоту входного сигнала Clk на два**.
    - **Пример:** Если осциллятор генерирует 20 импульсов в секунду (20 Гц), на выходе Q будет 10 импульсов в секунду (10 Гц).
- **Сквозной счетчик (Ripple Counter):** Последовательное соединение нескольких D-триггеров-делителей частоты (где выход Q одного триггера подключается к входу Clk следующего) образует сквозной счетчик. Такая схема может **считать в двоичной системе**. Изменения сигнала распространяются последовательно через все триггеры, что может вызывать небольшую задержку.
- **D-триггер с предустановкой (Pre) и очисткой (Clr), срабатывающий по фронту:** Этот тип D-триггера имеет дополнительные входы Pre (Preset - предустановка) и Clr (Clear - очистка), которые позволяют **устанавливать выход Q в 1 (Pre) или сбрасывать в 0 (Clr) асинхронно**, независимо от сигналов на входах D и Clk (при определенных условиях).
    - **Пример:** Подача низкого уровня сигнала (L) на вход Clr приводит к тому, что выход Q становится низким (L), а (\overline{Q}) - высоким (H). Аналогично, подача L на вход Pre приводит к тому, что Q становится H, а (\overline{Q}) - L.

**Про JK-триггеры и T-триггеры:**
Следует отметить, что **в "Глава 14. Обратная связь и триггеры" явно не описываются JK-триггеры и T-триггеры**. Эти типы триггеров являются более сложными комбинационными элементами на основе базовых триггеров (например, RS или D), но в данной главе они не представлены.
Однако, для вашего понимания, за пределами этой главы:
- **JK-триггер:** Представляет собой универсальный триггер, который устраняет запрещенное состояние RS-триггера (когда оба входа равны 1). Он имеет входы J и K, которые аналогичны S и R, но при J=1 и K=1 выход триггера переключается на противоположное состояние при каждом тактовом импульсе.
- **T-триггер (Toggle Flip-Flop):** Является разновидностью JK-триггера, где входы J и K соединены вместе. Он имеет один вход T (Toggle - переключение). При каждом тактовом импульсе, когда T=1, выход триггера меняет свое состояние на противоположное. Если T=0, состояние выхода не изменяется. T-триггер часто используется в счетчиках и делителях частоты.

## Глава 15. Байты и шестнадцатеричные числа

- Для представления байтов (8 бит) требуется более лаконичный способ записи, чем длинные последовательности нулей и единиц. Например, двоичное число **10110110** неудобно для быстрого восприятия.
- **Шестнадцатеричная система счисления (основание 16)** предлагает более краткий способ записи байтов. Одна шестнадцатеричная цифра представляет четыре бита, поэтому один байт может быть записан всего двумя шестнадцатеричными цифрами.
- В шестнадцатеричной системе используются цифры **0-9** и буквы **A-F** для представления значений от 10 до 15. Например, десятичное число **10** представляется как **A** в шестнадцатеричной системе, **11** как **B**, и так далее до **15**, которое представляется как **F**.
- Существует прямая связь между двоичной и шестнадцатеричной системами: каждую группу из четырех двоичных цифр можно легко преобразовать в одну шестнадцатеричную цифру.
    - Например, двоичное число **1011 0110** можно разбить на две группы по четыре бита: **1011** и **0110**.
    - **1011** в двоичной системе соответствует десятичному числу **11**, которое в шестнадцатеричной системе обозначается как **B**.
    - **0110** в двоичной системе соответствует десятичному числу **6**, которое в шестнадцатеричной системе обозначается как **6**.
    - Следовательно, двоичное число **10110110** в шестнадцатеричной системе записывается как **B6**.
- Аналогично, многобайтные значения также могут быть представлены в шестнадцатеричном формате, где каждый байт кодируется двумя шестнадцатеричными цифрами. Например, двухбайтовое двоичное число **11000101 10110110** можно представить как **C5 B6** в шестнадцатеричной системе.
- Преобразование из десятичной системы в шестнадцатеричную обычно involves деление на 16 с определением частного и остатка. Например, чтобы преобразовать десятичное число **182** в шестнадцатеричное, нужно разделить 182 на 16. Частное равно **11** (что соответствует **B** в шестнадцатеричной системе), а остаток равен **6**. Таким образом, **182** в десятичной системе эквивалентно **B6h** в шестнадцатеричной.
- Шестнадцатеричная система используется для согласованного представления отдельных байтов и многобайтных значений в компьютерной технике.
- При работе с 8-битными знаковыми двоичными числами отрицательные числа начинаются с **1**. В шестнадцатеричной системе двузначные числа со знаком являются отрицательными, если они начинаются с цифр **8, 9, A, B, C, D, E** или **F**, поскольку их двоичные эквиваленты начинаются с **1**. Например, **99h** может представлять как десятичное **153** (без знака), так и **-103** (со знаком).

## Глава 16. Сборка памяти

- **Память необходима для сохранения информации без искажений между моментами записи и чтения**. Различные типы памяти используются для разных видов информации, например, бумага для текста, магнитная лента для музыки и фильмов.
- Телеграфные реле, объединенные в вентили и триггеры, также могут хранить информацию.
- **Триггер способен хранить один бит информации**. Это является базовым элементом памяти.
- Несколько однобитных защелок можно объединить в многобитную память, соединив их входы "Запись". Защелка "запирает" один бит данных для дальнейшего использования и может рассматриваться как ячейка памяти емкостью один бит.
- **Оперативное запоминающее устройство (RAM) имеет адресные входы, входы и выходы данных, а также сигнал записи**.
- **Количество хранимых значений в массиве RAM определяется количеством адресных входов по формуле: 2 в степени количества адресных входов**. Например, 10 адресных входов позволяют хранить 2^10 = 1024 значения.
- Количество входов и выходов данных определяет разрядность (количество бит) каждого хранимого значения.
- Приведен пример массива RAM "1024 × 8", который может хранить 1024 восьмибитных (байтовых) значений, что составляет 8196 бит информации.
- Для создания значительного объема RAM с использованием телеграфных реле потребовалось бы огромное количество реле (например, почти пять миллионов для RAM 64 Кб × 8, учитывая, что на каждый бит памяти требуется девять реле).
- Для взаимодействия с RAM необходим **пульт управления**, который позволяет указывать адрес (например, с помощью 16 переключателей для массива 64 Кб), задавать 8-битное значение для записи (с помощью восьми переключателей), подавать сигнал записи и отображать считанное 8-битное значение (с помощью восьми лампочек).
- Конструкция RAM позволяет другим схемам использовать сохраненные значения и записывать в нее новые данные.

## Глава 17. Автоматизация

- **Автоматизация процесса сложения.** Глава посвящена созданию автоматизированной счетной машины, способной складывать несколько чисел, хранящихся в памяти. В отличие от ручного ввода чисел с помощью переключателей, автоматизация позволяет обрабатывать целые списки чисел.
    - **Пример:** Вместо того чтобы вручную вводить 100 чисел в сумматор, эти числа можно предварительно сохранить в RAM, и автоматизированный сумматор последовательно сложит их.
- **Необходимость сохранения промежуточных результатов.** Для сложения нескольких чисел требуется временно хранить промежуточные суммы, что достигается с помощью 8-битной защелки, называемой аккумулятором.
    - **Пример:** При сложении трех чисел первое число загружается в аккумулятор, затем к нему прибавляется второе, и результат сохраняется в аккумуляторе. После этого к содержимому аккумулятора прибавляется третье число.
- **Проблема ограниченности простого автоматизированного сумматора.** Первая версия автоматизированного сумматора имела ограничения, такие как невозможность остановить работу, обработка только 8-битных чисел и отсутствие вычитания. Также существовала проблема с использованием результатов в последующих операциях.
- **Введение кодов операций (команд).** Чтобы компьютер знал, что делать с данными в памяти, вводятся числовые коды, соответствующие операциям, таким как «Загрузка», «Сложение», «Сохранение» и «Остановка».
    - **Пример:** Код 10h может означать операцию «Загрузить», 11h — «Сохранить», 20h — «Сложить», 21h — «Вычесть», а FFh — «Остановить».
- **Разделение памяти на данные и код.** Для хранения чисел, подлежащих обработке, используется один массив RAM («Данные»), а для хранения кодов операций — другой («Код»).
- **Условный переход и циклы — ключевое отличие компьютера от калькулятора.** Вводится команда условного перехода (например, «Перейти, если не ноль» - JNZ), которая позволяет компьютеру повторять последовательность команд, образуя циклы. Это позволяет выполнять более сложные операции, такие как умножение.
    - **Пример:** Для умножения числа A7h на 1Ch (28 в десятичной системе), программа многократно складывает A7h с аккумулятором, пока счетчик не достигнет 28. Команда условного перехода позволяет повторять операцию сложения.
- **Появление термина «компьютер».** Благодаря возможности условного перехода, собранное устройство может быть названо компьютером. Компьютер работает с дискретными числами (цифровой).
- **Различение кода и данных.** В компьютерных программах различают код (сами команды) и данные (числа, которыми манипулирует код). Однако это различие не всегда очевидно.
- **Язык ассемблера как более удобная запись машинного кода.** Вводится понятие языка ассемблера, который представляет машинный код в более понятной для человека форме с использованием мнемонических кодов и символьных имен для адресов памяти.
    - **Пример:** Вместо записи машинного кода непосредственно в виде чисел, программист может использовать команды ассемблера, такие как LOD A, [1003h] (загрузить значение из ячейки памяти по адресу 1003h в аккумулятор A) или ADD A, [001Eh] (прибавить к аккумулятору значение из ячейки 001Eh).
- **Процесс программирования на языке ассемблера.** Для запуска программы, написанной на языке ассемблера, необходимо сначала вручную преобразовать ее в машинный код и затем ввести этот код в память компьютера с помощью переключателей.
- **Возможность выполнения более сложных операций.** Созданный компьютер, обладая операциями сложения и вычитания, а также условным переходом, теоретически способен выполнять умножение, деление, вычисление квадратных корней, логарифмов и тригонометрических функций с помощью программного обеспечения.

## Глава 18. От счетов к микросхемам

- **Переход от электромеханических реле к интегральным схемам (ИС) или микросхемам.** В главе рассматривается эволюция вычислительных устройств и переход от использования реле (как в описанном ранее 8-битном сумматоре, которому требовалось 144 реле) к применению интегральных схем.
- **Устройство и характеристики простой интегральной схемы (7408 quad two-input AND gate).** Описывается пример микросхемы, содержащей четыре логических элемента И с двумя входами каждая, приводятся схема расположения выводов (pinout), обозначения входов (A, B) и выхода (Y) для каждого элемента, а также разъясняется необходимость подключения питания (VCC) и земли (GND) для работы микросхемы.
    - **Пример:** Микросхема 7408 имеет 14 выводов, где выводы 1, 2 являются входами первого элемента И, вывод 3 — его выходом, и так далее.
- **Значение малых временных интервалов (наносекунды) для работы современных компьютеров.** Подчеркивается, что высокая производительность компьютеров обусловлена скоростью выполнения элементарных операций, которые происходят за очень короткие промежутки времени, такие как наносекунды. Роберт Нойс отмечает, что при понимании масштаба наносекунды, концепция работы компьютера становится довольно простой.
- **Основные действия компьютерного процессора и роль скорости их выполнения.** Напоминается, что процессор выполняет простые действия, такие как перемещение байта из памяти в регистр, сложение с другим байтом и возврат результата в память. Значимость работы компьютера определяется именно высокой скоростью выполнения этих базовых операций. Ранее также упоминались более быстрые сумматоры, использующие методы ускоренного переноса.
- **Введение в TTL (транзисторно-транзисторную логику) и D-триггер (74LS74A).** Рассматривается использование микросхем TTL, в частности, D-триггера со срабатыванием по положительному фронту, с функциями сброса (Clr) и предустановки (Pre). Приводится логическая схема и условное обозначение такого триггера.
- **Важность технической документации (datasheet) на микросхемы.** Упоминается, что для каждой микросхемы TTL существует справочник (datasheet) с подробным описанием логической схемы и таблицы истинности.
- **Использование осцилляторов на основе кварцевых кристаллов для тактирования.** Описывается применение кварцевых кристаллов для создания осцилляторов с предсказуемой частотой (в мегагерцах), которые используются в качестве тактового сигнала (Clk) для синхронизации работы цифровых схем. Предполагается, что компьютер, описанный в главе 17, при использовании микросхем TTL мог бы работать на тактовой частоте 10 МГц, выполняя каждую инструкцию за 400 наносекунд, что значительно быстрее релейных устройств.
- **Краткое упоминание о печатных платах (PCB) как способе соединения интегральных схем.** Сообщается, что для создания электронных устройств на основе ИС часто используются печатные платы с медными проводниками для электрического соединения компонентов. Промышленные печатные платы могут иметь несколько слоев для более сложной разводки.
- **Общее увеличение сложности и скорости компьютеров благодаря микросхемам.** Подчеркивается, что переход к микросхемам позволил значительно увеличить сложность и быстродействие вычислительных устройств по сравнению с электромеханическими аналогами. Несмотря на возросшую сложность, на концептуальном уровне отдельные операции, выполняемые компьютером, остаются простыми.

## Глава 19. Два классических микропроцессора

- **Представление микропроцессора как центрального процессора (ЦП) на одной кремниевой микросхеме**, появившегося в 1971 году. Первый микропроцессор Intel 4004 содержал около 2300 транзисторов, в то время как современные достигают десятков миллионов. Принцип работы на фундаментальном уровне остался прежним.
- **Рассмотрение микропроцессора Intel 8080 как «черного ящика»**, взаимодействие которого с внешним миром определяется входными и выходными сигналами, включая набор команд.
- **Тактовые сигналы:** Микросхеме 8080 требуются два тактовых сигнала с частотой два мегагерца, которые обычно генерируются с помощью отдельного чипа, например Intel 8224, к которому подключается кварцевый кристалл.
- **Адресные линии:** 8080 имеет 16 адресных линий (A0-A15), что позволяет адресовать **65 536 байт (64 килобайта) памяти**. 
- **Линии данных:** Микропроцессор 8080 является **8-разрядным**, поэтому считывает и записывает данные по восемь бит за один раз, используя линии D0-D7, которые являются двунаправленными (могут быть как входами, так и выходами).
- **Управляющие сигналы:** Десять контактов микропроцессора предназначены для управляющих сигналов, таких как **RESET** (сброс), **WR** (запись в память), и сигналы, указывающие на чтение команд из памяти. Система управляющих сигналов 8080 довольно сложна и обычно требует использования системного контроллера 8228.
- **Выборка команд:** После сброса процессор 8080 считывает байт из ячейки памяти 0000h, который должен быть кодом команды. Этот процесс называется выборкой команды. Команды 8080 могут занимать **один, два или три байта**.
- **Набор команд 8080:** Включает команды для загрузки данных из памяти (LDA), сохранения данных в память (STA), перемещения данных между регистрами и памятью (MOV).
    - **Пример:** `LDA A,[aaaa]` (загрузить байт по 16-битному адресу `aaaa` в аккумулятор A), `MOV B,[HL]` (переместить байт из ячейки памяти, адрес которой находится в регистровой паре HL, в регистр B).
- **Регистры:** Процессор 8080 имеет несколько 8-битных регистров, включая **аккумулятор (A)** и регистры **B, C, D, E, H, L**. Регистры используются для временного хранения данных внутри процессора, что ускоряет выполнение программ за счет уменьшения обращений к памяти.
- **Флаги:** Микросхема 8080 имеет пять флагов, которые хранятся в 8-битном регистре, называемом **словом состояния программы (PSW)**: флаг переноса, флаг нуля, флаг знака, флаг четности и флаг вспомогательного переноса. Эти флаги отражают результаты выполнения арифметических и логических операций.
    - **Пример:** Флаг нуля устанавливается в 1, если результат операции равен 0. Флаг переноса может устанавливаться (STC) или инвертироваться (CMC) отдельными командами.
- **Арифметические и логические операции:** Процессор 8080 способен выполнять сложение (ADD, ADC), вычитание (SUB, SBB), а также логические операции И (AND), ИЛИ (OR) и исключающее ИЛИ (XOR). Существуют версии этих команд, работающие как с регистрами, так и с непосредственными значениями.    
- **Инкремент и декремент:** Команды **INR** (инкремент) и **DCR** (декремент) увеличивают или уменьшают на 1 значение в регистре или ячейке памяти.
- **Стек:** Для временного хранения данных, например адресов возврата из подпрограмм, используется **стек**. Команды **PUSH** записывают значения регистров в стек, а команды **POP** извлекают их. Указатель стека (SP) хранит адрес вершины стека.
- **16-битные операции:** Помимо 8-битных, 8080 поддерживает некоторые 16-битные операции, такие как увеличение и уменьшение на 1 содержимого регистровых пар (INX, DCX) и сложение содержимого 16-битных регистровых пар с содержимым HL (DAD).
- **Команды перехода:** Существуют команды безусловного перехода (JMP) и **условного перехода**, которые позволяют изменять порядок выполнения команд в зависимости от значений флагов. Условные переходы являются ключевым элементом для создания универсального компьютера.
- **Подпрограммы:** Команды **CALL** (вызов подпрограммы) сохраняют адрес возврата в стеке и передают управление по указанному адресу, а команда **RET** (возврат) извлекает адрес возврата из стека и возобновляет выполнение основной программы.
- **Ввод/вывод (I/O):** Процессор 8080 имеет специальные команды **IN** (ввод) и **OUT** (вывод) для взаимодействия с периферийными устройствами через **порты ввода/вывода**, которых предусмотрено 256. Адреса портов задаются 8-битными числами.
- **Прерывания:** Периферийные устройства могут запрашивать внимание процессора с помощью сигналов **прерывания (INT)**. Процессор может разрешать (EI) или запрещать (DI) обработку прерываний. Выходной сигнал **INTE** указывает, разрешены ли прерывания.
- **Закон Мура:** Упоминается закон Мура, согласно которому количество транзисторов в микропроцессорах удваивается каждые 18 месяцев, что приводит к увеличению разрядности и появлению новых команд, например для работы с числами с плавающей точкой и обработки графики.
- **Необходимость остальной части компьютерной системы:** Подчеркивается, что микропроцессор является лишь частью компьютерной системы, которая также включает память, устройства ввода и вывода.

## Глава 20. Набор символов ASCII

- **Необходимость представления текста в двоичном формате для компьютеров**, поскольку в цифровой памяти хранятся только биты. Для работы с текстом, который является основной формой накопленной информации, требуется способ его кодирования.
- **Рассмотрение ранних систем кодирования символов и их недостатков для компьютеров**:
    - Азбука Морзе имеет коды разной длины и не различает регистр букв, что делает ее неудобной для компьютерной обработки. **Пример:** Буква 'E' кодируется одной точкой, а более редкие буквы — длинными комбинациями точек и тире.
    - Код Бодо использует 5-битные коды, что ограничивает количество символов. Для представления цифр и знаков препинания требуется **код переключения регистра**, что усложняет обработку.
- **Введение стандарта ASCII (American Standard Code for Information Interchange)** как **7-битного кода**, разработанного в 1967 году для обмена информацией. ASCII использует двоичные значения от 0000000 до 1111111 (шестнадцатеричные коды от 00h до 7Fh).
- **Структура набора символов ASCII**:
    - Первые **32 кода (00h-1Fh)** отведены для **управляющих символов**, которые не имеют графического представления, но выполняют определенные функции, например, синхронизация (SYN), конец блока передачи (ETB), отмена (CAN), перевод строки (LF), возврат каретки (CR), удаление (DEL). **Пример:** Коды возврата каретки (0Dh) и перевода строки (0Ah) используются для разделения строк текста.
    - Следующие **32 кода (20h-3Fh)** включают **знаки препинания, пробел и цифры**. **Пример:** Код 20h соответствует пробелу, 30h - цифре '0', 31h - цифре '1', 2Ch - запятой, 21h - восклицательному знаку.
    - Следующие **32 кода (40h-5Fh)** представляют **прописные буквы и некоторые дополнительные знаки препинания**, такие как @, [, , ], ^, _. **Пример:** Код 41h соответствует прописной букве 'A', 42h - 'B', 50h - 'P'.
    - Последние **32 кода (60h-7Fh)** включают **строчные буквы и дополнительные знаки препинания**, такие как `, {, |, }, ~. **Пример:** Код 61h соответствует строчной букве 'a', 62h - 'b', 70h - 'p'.
    - Существует **соотношение между кодами прописных и строчных букв**: они отличаются на 20h, что упрощает преобразование регистра. **Пример:** 'A' (41h) и 'a' (61h), 'B' (42h) и 'b' (62h).
- **Ограничения стандарта ASCII**:
    - **Ориентация на английский язык**: Отсутствуют символы, используемые в других языках, такие как символ британского фунта (£), буквы с диакритическими знаками, не говоря уже о нелатинских алфавитах (греческий, арабский, кириллица) и идеограммах азиатских языков.
    - Стандарт допускает **переопределение некоторых кодов** для национальных нужд, но это требует согласования между пользователями.
- **Расширения ASCII до 8 бит**: Поскольку большинство компьютерных систем используют 8-битные байты, набор ASCII часто расширяется до 256 символов (коды 00h-FFh). Коды 00h-7Fh остаются стандартными ASCII, а коды 80h-FFh используются для представления дополнительных символов, например, букв с диакритическими знаками и символов кириллицы.
- **Введение стандарта Unicode**:
    - Разработан в 1988 году как **16-битный стандарт**, призванный обеспечить **единую систему кодирования для всех языков мира**.
    - Unicode использует **два байта на символ**, предоставляя возможность кодирования 65 536 различных символов (от 0000h до FFFFh).
    - Первые **128 символов Unicode (0000h-007Fh) совместимы с ASCII**.
    - Unicode также включает другие мировые стандарты кодирования.
- **Преимущества и недостатки Unicode**:
    - **Преимущество**: Универсальность и однозначность кодирования для всех языков.
    - **Недостаток**: Увеличение размера хранимого текста, так как каждый символ занимает два байта вместо одного в ASCII. **Пример:** Роман, занимающий 1 Мбайт в ASCII, займет 2 Мбайта в Unicode.

## Глава 21. Шины

- **Шина представляет собой набор проводов, используемых для передачи данных между различными частями компьютера**. Это общий путь, по которому циркулирует информация.
    - Пример: Шина может соединять микропроцессор с памятью.
- Существуют **разные типы шин**, предназначенные для различных целей.
    - Пример: Шина адреса используется для указания местоположения в памяти, шина данных переносит сами данные, а шина управления передает сигналы, координирующие работу различных компонентов.
- Для эффективной работы шины необходимо **арбитраж шины**, механизм, определяющий, какое устройство имеет право использовать шину в данный момент.
    - Пример: Если несколько устройств хотят одновременно отправить данные по шине, арбитр шины решает, какое из них получит доступ первым.
- Важную роль в работе шины играют **выходные сигналы с тремя состояниями**. Это позволяет нескольким устройствам быть подключенными к одним и тем же линиям шины, но только одно из них может активно передавать данные в определенный момент, а выходы остальных находятся в состоянии высокого импеданса (отключены).
    - Пример: Микросхема статической памяти SRAM использует линии ввода данных шины. В любой момент только одна подключенная к шине плата может задействовать эти линии, а выходные сигналы остальных плат должны находиться в третьем состоянии.
- Накопители информации, такие как дискеты, жесткие диски и магнитные ленты, **подключаются к компьютеру через шины**, но микропроцессор напрямую обращается к памяти (RAM) по шине, а не к запоминающим устройствам.
    - Пример: Когда вы открываете файл с жесткого диска, данные сначала считываются с диска и передаются в оперативную память по шине, и только потом микропроцессор может с ними работать.
- Развитие шин шло параллельно с развитием технологий хранения данных. Появление более емких и быстрых носителей информации требовало и более производительных шин для передачи данных.

## Глава 22. Операционная система

- После сборки компьютера, состоящего из микропроцессора, оперативной памяти, клавиатуры, монитора и жесткого диска, **необходимо программное обеспечение для его функционирования**. При включении питания оперативная память оказывается в случайном состоянии и не содержит полезного кода.
- Первоначально машинные инструкции приходилось вводить вручную с помощью пульта управления, что было неудобно. **Для удобства взаимодействия требуется операционная система**.
- Первым шагом к созданию операционной системы является **разработка обработчика клавиатуры**, который прерывает работу микропроцессора при нажатии клавиши и запускает код для обработки ввода.
- Также необходим **код инициализации**, который выполняется при перезагрузке компьютера, устанавливает указатель стека и очищает экран.
- Далее разрабатывается **командный процессор**, который принимает от пользователя текстовые команды и выполняет их, например, запись данных в память или отображение содержимого памяти на экране.
- **Файловая система** является важной частью операционной системы и отвечает за сохранение и извлечение файлов на диске.
- Исторически важной операционной системой для 8-битных микропроцессоров была **CP/M** (Control Program for Micros).
- CP/M имеет **двухкомпонентную систему именования файлов**: имя файла (до восьми символов) и тип файла (до трех символов), разделенные точкой.
- **Запуск CP/M** осуществляется с помощью **загрузчика программы**, небольшого кода в ПЗУ, который считывает первый сектор с дискеты в память и запускает его, а тот, в свою очередь, загружает остальную часть CP/M.
- После загрузки CP/M размещается в оперативной памяти и состоит из трех основных компонентов: **базовая система ввода/вывода (BIOS)**, **базовая дисковая операционная система (BDOS)** и **консольный командный процессор (CCP)**.
- **Консольный командный процессор (CCP)** отображает приглашение и выполняет команды, вводимые пользователем.
- Операционная система, такая как CP/M, предоставляет **прикладной программный интерфейс (API)**, набор подпрограмм, которые облегчают программам доступ к аппаратному обеспечению компьютера (монитору, клавиатуре, диску), не требуя от программистов знания деталей взаимодействия с этими устройствами.
- Программы, работающие под CP/M, обращаются к функциям API через специальную команду перехода по определенному адресу (например, `CALL 5`), которая ведет к **BDOS**, отвечающей за файловую систему и использующей **BIOS** для взаимодействия с аппаратным обеспечением.
- Глава также кратко упоминает другие операционные системы, такие как **MS-DOS** с ее файловой системой FAT и механизмом программных прерываний (например, `INT 21h`), и **UNIX** как переносимую операционную систему.
- Подчеркивается тенденция развития операционных систем к созданию **графических пользовательских интерфейсов** (как в Apple Macintosh и Microsoft Windows) для упрощения работы с приложениями.

## Глава 23. Фиксированная точка, плавающая точка

- Глава посвящена способам представления в компьютерах чисел, которые не являются целыми, включая дроби и проценты.
- **Числа с фиксированной точкой** имеют заранее определенное количество знаков после запятой. Это удобно для представления величин с ограниченной точностью, например, денежных сумм (два десятичных знака для центов).
    - _Пример:_ Если мы используем фиксированную точку с двумя десятичными знаками, число 12.34 будет представлено как 1234 с подразумеваемой десятичной точкой после второй цифры.
- **Числа с плавающей точкой** используют экспоненциальную запись, аналогичную научной нотации. Они состоят из знака, порядка (экспоненты) и значащей части (мантиссы).
    - _Пример:_ Число 123.45 может быть представлено как 1.2345 × 10². В двоичной системе это будет выглядеть как ±(1,...)₂ × 2^(...).
- Существует **стандарт IEEE 754** для представления чисел с плавающей точкой, который включает два основных формата:    
    - **Одинарная точность:** занимает 4 байта (32 бита): 1 бит для знака, 8 бит для порядка и 23 бита для дробной части мантиссы.
    - **Двойная точность:** занимает 8 байтов (64 бита). (Эта информация прямо не указана в главе, но подразумевается как "двойной точности" по аналогии с одинарной).
- В нормализованном двоичном числе с плавающей точкой перед двоичной запятой всегда стоит 1. Этот бит не сохраняется в формате IEEE, что позволяет увеличить точность (до 24 бит для одинарной точности).
- **Точность чисел с фиксированной точкой** очевидна (например, точность до цента). **Точность чисел с плавающей точкой** зависит от порядка и составляет примерно до семи десятичных знаков для одинарной точности (что соответствует одной части из 2²⁴, или примерно шести частям из 100 миллионов).    
    - _Пример:_ Числа 16 777 216 и 16 777 217 могут быть представлены одним и тем же 32-битным числом с плавающей точкой, что демонстрирует ограниченную точность.
- Числа с плавающей точкой могут представлять как очень малые, так и очень большие числа, но с **ограниченной точностью**. В зависимости от порядка, точность может варьироваться.
- Глава подчеркивает, что, несмотря на удобство работы с целыми числами, дробями и процентами в повседневной жизни, их представление в компьютерах требует специальных подходов, таких как фиксированная и плавающая точка, каждая из которых имеет свои особенности и ограничения по точности.

## Глава 24. Языки высокого и низкого уровня

- Глава посвящена **различиям между языками программирования высокого и низкого уровней**.    
- **Язык ассемблера** считается **низкоуровневым**, поскольку он взаимодействует непосредственно с аппаратным обеспечением компьютера.
    - _Пример:_ В главе упоминаются мнемонические коды языка ассемблера для микропроцессора 8080, такие как MOV, ADD, CALL и HLT, которые отдаленно напоминают английские слова и часто сопровождаются операндами, уточняющими действие машинной инструкции. Например, команда `MOV B, [HL]` перемещает в регистр B содержимое ячейки памяти, адрес которой хранится в паре регистров HL.
- **Высокоуровневые языки программирования** абстрагируются от деталей аппаратного обеспечения и предоставляют более понятные для человека конструкции. Несмотря на то, что термин "язык высокого уровня" используется для описания любого языка программирования, отличного от языка ассемблера, некоторые языки считаются более высокоуровневыми по сравнению с другими.
    - _Пример:_ В качестве примера высокоуровневого языка, который является предком многих популярных языков, упоминается **АЛГОЛ (ALGOL)**. Глава также отмечает, что многие современные процессоры предусматривают команды побитового сдвига, которые практически отсутствуют в большинстве высокоуровневых языков программирования, и в таких случаях приходится имитировать их через умножение или деление на 2. Однако современное состояние языков C++, C# и Python включает такие операции, что является дополнением научного редактора.
- **Цель создания высокоуровневых языков** - облегчить процесс написания инструкций для компьютера, сделав их более похожими на естественный язык.
    - _Пример:_ Представляется идеальная, хотя и нереализованная, команда очень высокого уровня, которую мог бы ввести президент компании: "Рассчитать все прибыли и убытки за этот год, написать годовой отчет, распечатать несколько тысяч копий и разослать всем нашим акционерам".
- В ранние годы эры домашних компьютеров большинство прикладных программ писалось на **ассемблере**, однако в наши дни он используется редко.
- Несмотря на то, что в высокоуровневых языках могут отсутствовать некоторые низкоуровневые возможности (например, прямые команды побитового сдвига или булевы операции над битами в некоторых языках - хотя это и устаревшая информация), компиляторы могут оптимизировать код, используя низкоуровневые команды процессора (например, побитовые сдвиги для умножения/деления на степени двойки).
- Существует множество **разных высокоуровневых языков**, каждый со своими сторонниками и противниками. С 1950-х годов было изобретено и внедрено более тысячи высокоуровневых языков.

## Глава 25. Графическая революция


